## 基本概念

___

- **数据（Data）**：描述事物的符号记录。
- **数据库（DataBase, DB）**：长期存储在计算机内、有组织的、可共享的大量数据的集合。特点包括永久存储、有组织、可共享。
- **数据库管理系统（DataBase Management System, DBMS）**：位于用户与操作系统之间的一层数据管理软件。
- **数据库系统（DataBase System, DBS）**：由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator, DBA）组成，用于存储、管理、处理和维护数据的系统。
- **实体（Entity）**：客观存在并可相互区别的事物。
- **属性（Attribute）**：实体所具有的某一特性。
- **码（Key）**：唯一标识实体的属性集。
- **实体型（Entity Type）**：用实体名及其属性名集合来抽象和刻画同类实体。
- **实体集（Entity Set）**：同一实体型的集合。
- **联系（Relationship）**：指不同实体集之间的联系。
- **模式（Schema）**：数据库全体数据的逻辑结构和特征的描述，所有用户的公共数据视图。
  - **外模式（External Schema）**：数据库用户能看见和使用的局部数据的逻辑结构和特征的描述，与某一应用有关的数据的逻辑表示。
  - **内模式（Internal Schema）**：一个数据库的数据物理结构和存储方式的描述，数据库在内部的组织方式。

## 常用数据模型

___

### 层次模型（Hierarchical Model）
- **描述**：数据以树状结构组织，每个记录只有一个父节点，但可以有多个子节点。
- **示例**：组织结构图。公司的结构可以被表示为一个层次模型，其中CEO是根节点，下面是各个部门经理，再下面是员工。

### 网状模型（Network Model）
- **描述**：类似于层次模型，但每个记录可以有多个父节点和多个子节点。
- **示例**：交通运输网络。城市可以是节点，交通运输路线可以是节点之间的连接，每个城市（节点）可以通过多条路线（连接）与其他城市相连。

### 关系模型（Relational Model）
- **描述**：数据以表格的形式存储，表由行（元组）和列（属性）组成。
- **示例**：学生信息表。一个表格包含学生ID、姓名、年龄和班级，每个学生是一行，每个特征（如姓名）是一列。
  - **关系（Relation）**：学生信息表
  - **元组（Tuple）**：表中的一行，例如学生 "John Doe"
  - **属性（Attribute）**：表中的一列，例如 "姓名"
  - **码（Key）**：唯一确定一个元组的属性组，例如学生ID
  - **域（Domain）**：一组具有相同数据类型的值的集合，例如所有可能的学生姓名
  - **分量**：元组中的一个属性值，例如 "John Doe" 中的 "John"
  - **关系模式**：关系的描述，例如 学生(学生ID, 姓名, 年龄, 班级)

### 面向对象数据模型（Object Oriented Data Model）
- **描述**：数据和行为被封装在对象中，对象可以是现实世界实体的表示。
- **示例**：图书馆系统。每本书可以是一个对象，属性包括标题、作者和ISBN，行为可以包括借出和归还。

### 对象关系数据模型（Object Relational Data Model）

- **描述**：结合了关系模型和对象模型的特点，支持对象的概念，如继承、多态和封装。
- **示例**：员工管理系统。除了基本的员工信息（作为关系模型的一部分），还可以有对象表示员工的技能和资历，这些对象与员工对象相关联。

### 半结构化数据模型（Semistructure Data Model）
- **描述**：不需要固定的模式，数据结构可能是不规则或不完整的。
- **示例**：JSON或XML文档。例如，一个产品的JSON记录可以有价格、描述和可选字段，如尺寸或颜色，而这些字段并不在每个记录中都出现。

## SQL 操作

___

在数据库管理中，SQL (Structured Query Language) 是用于管理关系数据库的标准编程语言。以下是对常用 SQL 操作的详细说明和相应的示例。

### 数据库模式（Schema）

- **创建模式**：用于定义数据库的逻辑结构。
  
  ```sql
  -- 创建一个名为 'StudentDB' 的模式
  CREATE SCHEMA StudentDB;
  ```

### 基本表

- **创建表**：用于定义数据的结构，即表中的列和数据类型。
  
  ```sql
  -- 在 'StudentDB' 模式下创建一个名为 'Students' 的表
  CREATE TABLE StudentDB.Students (
      StudentID INT PRIMARY KEY,
      Name VARCHAR(100),
      Age INT,
      Major VARCHAR(100)
  );
  ```

- **修改表**：用于修改现有表的结构，如添加或删除列。
  
  ```sql
  -- 在 'Students' 表中添加一个名为 'GPA' 的列
  ALTER TABLE StudentDB.Students
  ADD GPA DECIMAL(3, 2);
  ```

### 视图（View）

- **创建视图**：视图是可查询的虚拟表，通常用于简化复杂的查询，不直接包含数据，但提供数据的一种视角。
  
  ```sql
  -- 创建一个名为 'View_StudentInfo' 的视图，展示学生的ID和姓名
  CREATE VIEW StudentDB.View_StudentInfo AS
  SELECT StudentID, Name
  FROM StudentDB.Students;
  ```

### 索引（Index）

- **创建索引**：索引用于加快对数据表中的数据检索速度。下面是在 `Name` 列上创建索引的示例。
  
  ```sql
  -- 在 'Students' 表的 'Name' 列上创建一个索引
  CREATE INDEX idx_name
  ON StudentDB.Students (Name);
  ```

### 数据

对于基本表和视图的常见操作包括查询、插入、更新和删除数据：

- **查询（SELECT）**
  
  ```sql
  -- 查询 'Students' 表中所有记录
  SELECT * FROM StudentDB.Students;
  
  -- 查询 'Students' 表中姓名为 'John Doe' 的学生信息
  SELECT * FROM StudentDB.Students
  WHERE Name = 'John Doe';
  ```

- **插入（INSERT）**
  
  ```sql
  -- 向 'Students' 表中插入一条新记录
  INSERT INTO StudentDB.Students (StudentID, Name, Age, Major)
  VALUES (1, 'John Doe', 20, 'Computer Science');
  ```

- **更新（UPDATE）**
  
  ```sql
  -- 更新 'Students' 表中某学生的专业
  UPDATE StudentDB.Students
  SET Major = 'Mathematics'
  WHERE StudentID = 1;
  ```

- **删除（DELETE）**
  
  ```sql
  -- 从 'Students' 表中删除一条记录
  DELETE FROM StudentDB.Students
  WHERE StudentID = 1;
  ```

- **权限操作（GRANT, REVOKE）**
  
  ```sql
  -- 授予用户对 'Students' 表的 SELECT 权限
  GRANT SELECT ON StudentDB.Students TO some_user;
  
  -- 撤销用户对 'Students' 表的 SELECT 权限
  REVOKE SELECT ON StudentDB.Students FROM some_user;
  ```

### 属性列

对属性列的操作通常与数据操作相似，但针对特定的列：

- **查询特定列（SELECT）**
  
  ```sql
  -- 仅查询 'Students' 表中学生的姓名和专业
  SELECT Name, Major FROM StudentDB.Students;
  ```

- **更新特定列（UPDATE）**
  
  ```sql
  -- 更新 'Students' 表中某学生的年龄
  UPDATE StudentDB.Students
  SET Age = 21
  WHERE StudentID = 1;
  ```

## 关系型数据库

___

关系型数据库是基于关系模型的，使用一系列的表来存储数据及其关系。在这种模型中，表由行和列组成，每一行代表一个数据项，每一列代表一个数据字段。

### 基本关系操作

1. **查询操作**：
   
   - **选择（Selection）**：从表中选取满足特定条件的行。
     ```sql
     -- 选择所有年龄大于20的学生
     SELECT * FROM Students WHERE Age > 20;
     ```
   - **投影（Projection）**：从表中选取特定的列。
     
     ```sql
     -- 仅显示学生的姓名和年龄
     SELECT Name, Age FROM Students;
     ```
   - **连接（Join）**：将两个或多个表的行组合起来，根据一定的条件。
     - **等值连接（Equi-Join）**：基于两个表中的列的等值关系来连接表。
       ```sql
       -- 连接 Students 表和 Scores 表，基于 StudentID
       SELECT * FROM Students INNER JOIN Scores ON Students.StudentID = Scores.StudentID;
       ```
     - **自然连接（Natural Join）**：自动为你匹配和连接两个表中相同名称的列。
       ```sql
       -- 自然连接 Students 表和 Scores 表
       SELECT * FROM Students NATURAL JOIN Scores;
       ```
     - **外连接（Outer Join）**：包括 LEFT OUTER JOIN, RIGHT OUTER JOIN, 和 FULL OUTER JOIN，不仅返回符合连接条件的行，还返回左表、右表或两边表中未匹配的行。
       ```sql
       -- 左外连接，即使右表（Scores）中没有匹配，也返回左表（Students）的所有行
       SELECT * FROM Students LEFT OUTER JOIN Scores ON Students.StudentID = Scores.StudentID;
       ```
    ```
   - **除（Division）**、**并（Union）**、**差（Difference）**、**交（Intersection）**、**笛卡尔积（Cartesian Product）** 等也是关系操作的一部分，但不如上述操作常用。
    ```
   
2. **数据修改操作**：
   - **插入（Insert）**：向表中添加新行。
     ```sql
     -- 向 Students 表中插入一条记录
     INSERT INTO Students (StudentID, Name, Age, Major) VALUES (1, 'John Doe', 20, 'Computer Science');
     ```
   - **删除（Delete）**：从表中删除行。
     ```sql
     -- 从 Students 表中删除年龄大于 22 的所有学生
     DELETE FROM Students WHERE Age > 22;
     ```
   - **修改（Update）**：更新表中的现有行。
     ```sql
     -- 更新 Students 表中的学生，将名为 John Doe 的学生的专业修改为 'Mathematics'
     UPDATE Students SET Major = 'Mathematics' WHERE Name = 'John Doe';
     ```

### 关系模型完整性约束

1. **实体完整性**：确保每个表的主键都是唯一的，且不包含 NULL 值。
   - 例如，在创建表时定义主键：
     ```sql
     CREATE TABLE Students (
         StudentID INT PRIMARY KEY,
         Name VARCHAR(100),
         Age INT
     );
     ```

2. **参照完整性**：确保一个表中的外键值必须在另一个表的主键中有对应的值或者是 NULL。
   - 例如，如果有一个 Scores 表，其中包含一个指向 Students 表的外键：
     ```sql
     CREATE TABLE Scores (
         ScoreID INT PRIMARY KEY,
         StudentID INT,
         Score INT,
         FOREIGN KEY (StudentID) REFERENCES Students(StudentID)
     );
     ```

3. **用户定义的完整性**：满足特定业务规则的约束。
   
   - 例如，确保学生的年龄不能小于 18：
     ```sql
     ALTER TABLE Students
     ADD CONSTRAINT chk_Age CHECK (Age >= 18);
     ```

## 索引

___

​	索引是数据库中的一种数据结构，可以提高数据检索的速度。就像书籍末尾的索引一样，数据库索引帮助数据库服务器快速定位存储在数据表中的数据。

### 数据库索引类型

1. **顺序索引（Sequential Index）**：
   - **描述**：顺序索引是在数据的物理存储顺序上构建的索引。是基于表中数据的自然顺序。
   - **适用场景**：适用于经常需要按顺序检索的数据。
   - **示例**：图书馆的书籍编号，通常按照书籍的编号顺序存放。

2. **B+ 树索引（B+ Tree Index）**：
   - **描述**：B+ 树索引是一种自平衡的树结构，在关系型数据库中广泛使用。每个非叶节点代表了其子节点中的最大（或最小）值。叶节点包含了指向数据的指针。
   - **适用场景**：适用于大量数据的快速检索，插入，删除操作。尤其是在需要范围查询和有序遍历时。
   - **示例**：在一个用户数据库中，可能会基于用户的ID或用户名建立 B+ 树索引以快速检索用户信息。

3. **Hash 索引（Hash Index）**：
   - **描述**：Hash 索引使用哈希表来存储数据。每个数据项通过哈希函数映射到一个特定的位置。
   - **适用场景**：适用于等值查询，比如在键值对数据结构中快速找到特定的值。
   - **示例**：在一个密码数据库中，为了快速验证用户登录，系统可能会对用户密码进行哈希处理，并在登录时比对哈希值。

### 深入理解 MySQL 索引

MySQL中的索引通常使用 B+ 树索引。这里对 B+ 树索引背后的数据结构及算法原理进行深入解析：

- **B+ 树的结构**：
  - B+ 树是一种多路平衡查找树，的每个节点最多可以包含 k 个孩子（k-1 个关键字）。B+ 树中的所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，叶子节点之间通过指针相互链接。
  - 非叶节点（内部节点）存储的是键值，用于指导搜索方向，实际的数据记录存储在叶子节点中。
  
- **B+ 树的优势**：
  - **查询速度稳定**：B+ 树的所有查询都需要从根节点到叶节点，查询性能稳定。
  - **全键值遍历更快**：由于叶子节点包含了全部键值信息且相互链表，便于对全体数据进行遍历。
  - **范围查询方便**：B+ 树支持范围查找和排序查找，能够快速找到指定范围的所有数据。
  
- **索引维护**：
  - 当数据表中的数据发生变化时（如INSERT, DELETE, UPDATE操作），索引也需要随之更新，保持数据与索引的一致性。
  - 虽然索引能极大地提高查询速度，但同时也会稍微减慢数据的插入、删除和修改操作，因为在进行这些操作时，数据库系统还需要维护索引的结构。

###  示例

假设有一个学生表 `Students`，其中包含学生的ID，姓名和年龄。如果经常根据学生的姓名来检索信息，可能会为 `Name` 列建立一个索引：

```sql
CREATE INDEX idx_name ON Students (Name);
```

在这个例子中，如果使用 B+ 树索引，数据库会根据学生的姓名构建一个 B+ 树。当执行一个查询，比如查找名为 "John Doe" 的学生时：

```sql
SELECT * FROM Students WHERE Name = 'John Doe';
```

数据库可以使用索引来快速定位到名为 "John Doe" 的学生的记录，而不需要扫描整个 `Students` 表，从而显著提高查询效率。

### 顺序索引 vs B+ 树索引 vs Hash 索引

#### 速度：

- **顺序索引**：
  - 查询速度：适用于有序数据的顺序访问。在最好情况下（数据已排序），顺序扫描速度很快。但如果要查询的数据分布广泛，则可能需要遍历整个索引。
  
- **B+ 树索引**：
  - 查询速度：对于范围查询和有序数据访问非常快。B+ 树索引对于等值查询和范围查询都能提供良好的性能，因为们都是基于树的结构，允许快速的数据定位和有序访问。
  
- **Hash 索引**：
  - 查询速度：对于等值查询（例如精确查找）非常快，因为直接将键映射到表中的位置。但对于范围查询则不是很适用。

#### 适用场景：

- **顺序索引**：
  - 主要适用于那些经常需要按顺序访问数据的场景。如果数据自然排序，并且查询经常涉及大量连续的记录，则顺序索引非常高效。
  
- **B+ 树索引**：
  - 适用于大量数据的环境，并且需要支持多种类型的查询，包括等值查询、范围查询和排序操作。是大多数数据库系统的默认索引类型。

- **Hash 索引**：
  - 适用于快速等值查询，例如键值查找。在只有精确匹配条件的查询中表现最好。

#### 特点：

- **顺序索引**：
  - 简单，容易实现。
  - 对于有序数据或者顺序访问非常高效。
  - 不适合频繁修改的数据，因为插入和删除操作可能需要大量的数据移动。
  
- **B+ 树索引**：
  - 所有记录节点都存放在叶子节点上，非叶节点只存储键值信息，因此更稳定。
  - 支持顺序访问和快速查找。
  - 由于树的平衡特性，插入和删除操作可以在对数时间内完成，即使是大量数据也是如此。
  
- **Hash 索引**：
  - 提供非常快速的查询响应，特别是对于等值查询。
  - 不支持范围查询和排序操作。
  - 哈希冲突可能会影响性能，特别是在负载较高的情况下。

## 数据库完整性与安全性

___

- **完整性**
  - 数据的正确性和相容性的保证。
  - 防止数据库中存在不符合语义（不正确）的数据。
- **安全性**
  - 保护数据库防止恶意破坏和非法存取。
- **触发器**
  - 用户定义在关系表中的一类由事件驱动的特殊过程。

## 关系数据理论

___

数据库的完整性和安全性是维护数据质量和保护数据不受不当访问的重要方面。

### 完整性 (Integrity)

- **定义**：数据库完整性确保数据的准确性和一致性。防止了数据被不正确地修改，无论是由于系统错误、人为错误还是设计缺陷。
  
- **类型**：
  
  - **实体完整性**：确保每个表都有一个唯一的标识符，如主键，且主键列不能有 NULL 值。
  - **参照完整性**：确保表之间的关系保持一致，即外键值必须在相关表的主键中有对应值或者是 NULL。
- **用户定义完整性**：确保数据符合业务规则，如数据范围、格式和逻辑约束。
  
- **示例**：
  - **实体完整性示例**：
    ```sql
    -- 创建学生表，确保每个学生都有唯一的学生ID
    CREATE TABLE Students (
        StudentID INT PRIMARY KEY,
        Name VARCHAR(100),
        Age INT
    );
    ```
  - **参照完整性示例**：
    ```sql
    -- 创建成绩表，确保成绩表中的学生ID与学生表中的学生ID相对应
    CREATE TABLE Grades (
        GradeID INT PRIMARY KEY,
        StudentID INT,
        Grade CHAR(1),
        FOREIGN KEY (StudentID) REFERENCES Students(StudentID)
    );
    ```
  - **用户定义完整性示例**：
    ```sql
    -- 确保学生的年龄在合理的范围内
    ALTER TABLE Students
    ADD CONSTRAINT chk_Age CHECK (Age >= 5 AND Age <= 18);
    ```

### 安全性 (Security)

- **定义**：数据库安全性是指保护数据免受未经授权的访问和修改。包括用户身份验证、授权、数据加密和审计等机制。
  
- **措施**：
  - **用户身份验证**：确认用户的身份，例如通过用户名和密码。
  - **访问控制**：限制用户对数据库对象的访问，例如通过角色和权限。
  - **数据加密**：加密存储在数据库中的数据，确保即使数据被盗也难以解读。
  - **审计**：记录和审查数据库操作，以检测和防止不当行为或潜在的安全问题。

- **示例**：
  - **授予权限示例**：
    
    ```sql
    -- 授予用户对学生表的 SELECT 和 UPDATE 权限
    GRANT SELECT, UPDATE ON Students TO some_user;
    ```
  - **撤销权限示例**：
    ```sql
    -- 撤销用户对成绩表的所有权限
    REVOKE ALL PRIVILEGES ON Grades FROM some_user;
    ```

### 触发器 (Trigger)

- **定义**：触发器是数据库中的一种特殊类型的存储过程，会在特定事件发生时自动执行，如对表进行 INSERT、UPDATE 或 DELETE 操作时。
  
- **用途**：
  - 自动执行检查或更新数据的操作。
  - 维护数据库完整性。
  - 记录数据变更的历史。

- **示例**：
  - **创建触发器示例**：
    ```sql
    -- 创建一个触发器，在向学生表插入新记录时自动记录时间
    CREATE TRIGGER trg_AfterInsert
    AFTER INSERT ON Students
    FOR EACH ROW
    BEGIN
       INSERT INTO Audit(StudentID, Operation, OperationTime)
       VALUES (NEW.StudentID, 'INSERT', NOW());
    END;
    ```

在这个示例中，`trg_AfterInsert` 触发器会在向 `Students` 表插入新记录之后自动执行。会在 `Audit` 表中插入一个新记录，记录新插入的学生ID、操作类型（INSERT）以及操作发生的时间。

## 数据库范式

___

### 范式（Normalization）
数据库设计的核心目标是确保数据的一致性和完整性。范式是达成这一目标的规则集合。
- **第一范式 (1NF)**：属性是最小单位，不可再分。
- **第二范式 (2NF)**：满足 1NF，且每个非主属性完全依赖于主键（消除非主属性对码的部分函数依赖）。
- **第三范式 (3NF)**：满足 2NF，且任何非主属性不依赖于其他非主属性（消除非主属性对码的传递函数依赖）。
- **鲍依斯-科得范式 (BCNF)**：满足 3NF，且任何非主属性不能对主键子集依赖（消除主属性对码的部分和传递函数依赖）。
- **第四范式 (4NF)**：满足 3NF，且属性之间不能有非平凡且非函数依赖的多值依赖（消除非平凡且非函数依赖的多值依赖）。

## 数据库恢复

___

​	数据库恢复是数据管理中的一个重要方面，它确保在系统故障、硬件故障、用户错误或其他异常情况下，数据可以被正确地恢复到某个一致的状态。

### 事务和 ACID 特性

- **定义**：事务是一系列操作，这些操作要么全部执行，要么全部不执行。事务是数据库完整性的关键。

- **ACID 特性**：
  - **原子性（Atomicity）**：确保事务中的所有操作要么全部完成，要么全部不发生。即使在系统故障时，事务的原子性也得到保障。
  - **一致性（Consistency）**：确保每次事务都将数据库从一个一致的状态转换到另一个一致的状态。
  - **隔离性（Isolation）**：确保并发运行的事务不会互相干扰。
  - **持久性（Durability）**：确保事务一旦提交，其结果就是永久性的，即使系统发生故障也不会丢失。

### 数据库恢复的实现技术

1. **数据转储**：
   - **动态海量转储（Dynamic Full Dumping）**：在系统运行时定期将整个数据库复制到备份介质。
   - **动态增量转储（Dynamic Incremental Dumping）**：仅将自上次转储以来已修改的数据复制到备份介质。
   - **静态海量转储（Static Full Dumping）**：在系统关闭时，将整个数据库复制到备份介质。
   - **静态增量转储（Static Incremental Dumping）**：在系统关闭时，仅将自上次转储以来已修改的数据复制到备份介质。

2. **登记日志文件**：
   - **定义**：数据库的每次变更都会在日志文件中记录下来，包括开始事务、修改数据和结束事务的信息。
   - **作用**：在数据库发生故障时，可以使用日志文件来恢复被损坏或丢失的数据。日志文件的使用通常分为以下两个步骤：
     - **回滚（Undo）**：取消未完成的事务。如果系统故障时有事务未完成，日志文件会被用来撤销这些事务所做的所有修改。
     - **重做（Redo）**：重新应用已完成的事务。即使在系统故障后，也保证已提交的事务所做的修改不会丢失。

### 示例

假设有一个简单的银行数据库，其中有一个 `Accounts` 表，用于存储客户的账户信息。考虑以下的转账事务：

```sql
-- 转账事务
BEGIN TRANSACTION;

-- 从账户 A 扣除 100 美元
UPDATE Accounts SET balance = balance - 100 WHERE account_id = 'A';

-- 给账户 B 增加 100 美元
UPDATE Accounts SET balance = balance + 100 WHERE account_id = 'B';

COMMIT;
```

这个事务包含两个操作：从账户 A 中扣除金额，并向账户 B 中增加相同的金额。这个事务要么完全执行（如果两个 `UPDATE` 操作都成功），要么完全不执行（如果任一 `UPDATE` 操作失败），以此保证数据库的一致性。

如果在执行事务过程中发生系统崩溃，数据库的恢复机制会利用日志文件来确定哪些操作需要撤销，哪些需要重做。例如，如果上述事务在提交之前系统崩溃了，恢复机制会回滚事务，确保账户 A 和账户 B 的余额保持不变。如果事务已经提交，那么即使系统崩溃，转账操作也会被保留，保证了事务的持久性。

## 并发控制

___

在数据库系统中，当多个事务同时运行时，可能会试图同时访问和修改相同的数据。并发控制是数据库管理系统（DBMS）用来确保数据一致性和事务隔离性的一套机制和策略。

### 并发操作带来的问题

在没有适当并发控制的情况下，可能会出现以下问题：

1. **丢失修改（Lost Update）**：
   - 情景：两个事务同时修改同一条记录。一个事务的更新可能被另一个事务的更新覆盖。
   - 示例：两个银行柜员同时更新同一个账户的余额。一个柜员的更新会丢失，因为另一个柜员的更新覆盖了它。

2. **不可重复读（Non-repeatable Read）**：
   - 情景：一个事务在读取某些数据后，另一个事务修改了这些数据。当第一个事务再次读取相同的数据时，会发现数据已经改变。
   - 示例：一个事务读取了员工的工资，而另一个事务在此期间增加了该员工的工资。当第一个事务再次读取工资时，发现工资已变化。

3. **读“脏”数据（Dirty Read）**：
   - 情景：一个事务读取了另一个未提交事务修改的数据。如果那个未提交的事务最终回滚，第一个事务就读取了永远不会被提交的数据。
   - 示例：一个事务读取了另一个事务修改的账户余额，但那个修改的事务最终失败并回滚。这意味着第一个事务读取了一个无效的余额。

### 并发控制技术

为了解决上述问题，数据库系统实现了多种并发控制技术：

1. **封锁（Locking）**：
   - 排他锁（X 锁 / 写锁）：确保当一个事务在修改数据时，其他事务不能同时修改或读取同一数据。
   - 共享锁（S 锁 / 读锁）：允许多个事务同时读取同一数据，但在共享锁持有期间，数据不能被修改。

2. **时间戳**：
   - 每个事务被赋予一个唯一的时间戳。系统根据时间戳来决定事务的优先级，以解决数据访问冲突。

3. **乐观控制法（Optimistic Concurrency Control）**：
   - 假设事务之间的冲突很少发生，事务在提交前不会被封锁。在提交时，系统检查是否存在冲突，如果存在，则事务被回滚。

4. **多版本并发控制（MVCC）**：
   - 同时维护数据的多个版本，以支持读操作和写操作的并发性。这通常用于实现不可重复读和幻读问题的解决方案。

### 活锁和死锁

在并发控制中，还可能出现活锁和死锁的问题：

1. **活锁**：
   - 事务永远处于等待状态，因为它们不断地重复相同的冲突解决策略，而没有进展。
   - **预防策略**：实施**先来先服务**策略，确保事务以一定的顺序执行。

2. **死锁**：
   - 两个或多个事务相互等待对方释放锁，造成系统停滞不前。
   - **预防和解除策略**：
     - **一次封锁法**：事务开始时一次性获取所有需要的锁。
     - **顺序封锁法**：事务必须按照一定的顺序获取锁。
     - **超时法**：事务等待锁的时间超过某个阈值时，就放弃，回滚事务。
     - **等待图法**：数据库系统维护一个等待图，用以检测和解决死锁。
     - **解除策略**：当检测到死锁时，选择并撤销处理死锁代价最小的事务，并释放其所有锁。

### 示例：银行转账并发控制

考虑两个并发事务，一个是从账户 A 向账户 B 转账，另一个是从账户 B 向账户 C 转账：

- **事务 1**：
  - `BEGIN TRANSACTION;`
  - `SELECT balance FROM Accounts WHERE account_id = 'A';`
  - `UPDATE Accounts SET balance = balance - 100 WHERE account_id = 'A';`
  - `UPDATE Accounts SET balance = balance + 100 WHERE account_id = 'B';`
  - `COMMIT;`

- **事务 2**：
  - `BEGIN TRANSACTION;`
  - `SELECT balance FROM Accounts WHERE account_id = 'B';`
  - `UPDATE Accounts SET balance = balance - 50 WHERE account_id = 'B';`
  - `UPDATE Accounts SET balance = balance + 50 WHERE account_id = 'C';`
  - `COMMIT;`

在没有适当并发控制的情况下，两个事务可能会相互影响，导致不可预知的结果，如丢失修改。使用封锁或其他并发控制技术可以确保每个事务都在一个隔离的环境中执行，从而维护数据库的一致性和隔离性。

## 可串行化调度

___

在数据库系统中，可串行化（Serializability）是并发控制的最高标准。它确保当多个事务并发执行时，最终的结果与这些事务按某个顺序依次执行（串行执行）时的结果相同。这种性质是数据库并发控制的核心，旨在保证数据的一致性和完整性。

### 可串行化调度的定义

- **定义**：可串行化调度是指，多个事务的并发执行结果等同于它们以某种顺序串行执行的结果。这意味着事务的执行虽然是并发的，但从逻辑上看，**它们的执行效果与按某个顺序一个接一个执行相同。**

### 可串行化的重要性

- **数据一致性**：确保即使在并发环境下，数据也保持一致状态，没有冲突和异常。
- **事务隔离**：即使多个事务同时运行，每个事务也好像是在独立运行，不受其他事务的影响。
- **系统可靠性**：通过确保并发事务的可串行化，数据库系统提供了对数据一致性和完整性的强保障。

### 可串行化的实现

实现可串行化的主要方法是通过各种并发控制协议，如两阶段锁定协议（2PL）和时间戳排序协议。这些协议通过控制事务对数据项的访问来确保可串行化：

1. **两阶段锁定协议（2PL）**：在事务的生命周期中分为两个阶段对数据项进行加锁和解锁。第一阶段是加锁阶段，事务可以获得锁但不能释放任何锁；第二阶段是解锁阶段，事务释放所有锁但不能获得新的锁。
2. **时间戳排序协议**：给每个事务分配一个唯一的时间戳。系统根据时间戳来决定事务的执行顺序，从而保证事务的可串行化。

## 执行一条select语句，发生了什么

- 连接器：建立TCP连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

## MySQL 一行记录是怎么存储的？

#### 数据页和行格式

InnoDB存储引擎将数据存储在页面（Page）中，每个页面默认大小为16KB。这些页面按一定的顺序组织在磁盘上。InnoDB支持多种行格式，如`COMPACT`、`REDUNDANT`、`DYNAMIC`和`COMPRESSED`，不同的行格式决定了记录在磁盘上的存储方式。

- **REDUNDANT**：这是InnoDB早期版本的行格式，提供了最基本的存储特性。
- **COMPACT**：相较于REDUNDANT，减少了一些元数据的存储，是一种更加紧凑的存储方式。
- **DYNAMIC**：对BLOB、TEXT、VARBINARY等类型的处理更加高效，存储方式更加灵活和紧凑。
- **COMPRESSED**：允许对整个页进行压缩，节省磁盘空间。

#### 行的存储结构

以`COMPACT`行格式为例，一行记录大体可以分为以下几个部分：

1. **变长字段长度列表**：如果行中包含变长字段（如VARCHAR），这部分用于记录这些变长字段的长度。
2. **NULL值标记**：每个可以为NULL的列都对应一个位，用于标记该列是否为NULL。
3. **记录头信息**：包含一些元数据，如事务ID、回滚指针等，用于支持MVCC。
4. **列值**：实际的列值数据，固定长度的列如INT会直接存储，变长列如VARCHAR根据变长字段长度列表存储。

#### 主键和索引

- **主键索引（聚集索引）**：InnoDB要求表必须有主键（没有显式定义主键时，InnoDB会自动选择或生成一个），一行数据的物理存储位置就是按照主键索引来组织的。这意味着具有相近主键值的行物理上也存储得比较近。
- **二级索引（非聚集索引）**：指向聚集索引的键值，而不是直接指向行的物理位置。因此，使用二级索引访问数据时，通常会先查找到主键，然后再通过主键索引找到数据行。

## varcha(n)里n的最大值

在MySQL中，`VARCHAR(n)`类型中的`n`代表字符的最大数量，而不是字节的大小。`n`的最大值取决于多个因素，包括表的字符集和MySQL行数据大小的限制。MySQL规定，一行数据的总字节长度（除了`TEXT`和`BLOB`类型的列外）不能超过65535字节。

### 单字段情况下的`VARCHAR(n)`最大取值

- 对于只有一个`VARCHAR(n)`字段的表，`n`的最大值取决于字符集以及每行数据的最大存储限制（65535字节），同时还需要减去记录头信息、变长字段长度列表和NULL值列表所占用的字节数。
- 如果表的字符集为ASCII（1个字符=1字节），理论上最大`n`值为`65532`，因为：
  - 1字节用于NULL值列表（如果字段可为NULL）。
  - 2字节用于表示变长字段的长度（因为最大长度超过255字节）。
  - 因此，`65535 - 1 - 2 = 65532`。

### 多字段情况下的`VARCHAR(n)`最大取值

- 在有多个字段的情况下，所有字段的长度加上变长字段长度列表和NULL值列表所占用的字节总数必须小于或等于65535字节。
- 对于UTF-8字符集（1个字符最多占用3字节），`VARCHAR(n)`的最大取值更加复杂，因为需要考虑字符集的最大字符长度。例如，对于UTF-8，最大的`n`值将远小于65532。

### 行溢出处理

- 对于超过页面大小（默认16KB）的数据，如某些`VARCHAR(n)`列或大对象类型（`TEXT`、`BLOB`），MySQL通过行溢出机制处理。溢出的数据会被存储在额外的页面中（称为溢出页），而在原始记录中只保留指向这些溢出页的指针。
- 不同的行格式（如`COMPACT`、`DYNAMIC`、`COMPRESSED`）在处理行溢出数据时有所不同。`COMPACT`行格式可能会在记录中保留部分数据和一个指向溢出页的指针，而`DYNAMIC`和`COMPRESSED`行格式仅存储指向溢出页的指针。

总之，`VARCHAR(n)`中的`n`最大取值取决于表的字符集、行格式和其他字段的存在。在实践中，设计表结构时应该考虑到这些限制，以确保数据存储的高效性和灵活性。

## 索引的分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

## 索引查找数据的过程

### 通过主键查询数据的过程

1. **定位到聚集索引**：由于InnoDB的表是索引组织表，表数据按照主键顺序存储，这种存储结构也被称为聚集索引（Clustered Index）。因此，通过主键查询数据直接定位到聚集索引。
2. **B-Tree搜索**：InnoDB使用B+Tree作为索引结构。查询时，从B+Tree的根节点开始，通过比较节点中的键值，逐级向下搜索，直到找到对应的叶子节点。叶子节点包含了完整的行记录数据。
3. **返回结果**：一旦找到了叶子节点，就获取到了完整的行数据，查询过程结束。

这个过程是非常高效的，因为数据行就存储在叶子节点中，不需要额外的步骤就能获取到数据。

### 通过非主键（二级索引）查询数据的过程

1. **定位到二级索引**：非主键查询首先定位到对应的二级索引B+Tree结构。每个二级索引都是一个单独的B+Tree，其叶子节点包含了主键的值，而不是完整的行数据。
2. **B-Tree搜索**：和主键查询一样，从二级索引的B+Tree根节点开始，逐级向下搜索，直到找到对应的叶子节点。
3. **通过主键定位聚集索引**：二级索引的叶子节点存储了主键的值，使用这个值再次通过聚集索引的B+Tree搜索，找到包含完整行数据的叶子节点。
4. **返回结果**：找到聚集索引的叶子节点后，获取到完整的行数据，查询过程结束。

通过非主键查询数据的过程比通过主键查询的过程多了一个步骤，即首先要通过二级索引找到主键值，然后再通过主键值去聚集索引中查找实际的数据。这个额外的步骤称为“回表”操作，因为它需要回到聚集索引中去查找最终的数据。这也是为什么通常说非主键查询比主键查询要慢的原因。

## 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？

### 1. B+Tree vs B树

- **更高的查询效率**：B+Tree的设计使得所有数据都存储在叶子节点，并且叶子节点之间以双链表的形式相连，这不仅减少了非叶子节点的大小，使得每个节点可以存储更多的键值，从而降低了树的高度，也使得顺序访问变得非常高效。
- **优化的范围查询**：由于B+Tree的叶子节点是顺序链接的，它可以非常高效地支持范围查询，这对数据库操作尤为重要，因为数据库的查询往往不限于单个键值的查找。

### 2. B+Tree vs 二叉树

- **更低的树高度**：二叉树的节点最多只有两个子节点，这意味着对于相同数量的数据，二叉树的高度会更高，导致查询、插入和删除操作需要更多的磁盘I/O。B+Tree通过增加分支数，大幅度降低树的高度，从而提高操作效率。
- **磁盘I/O优化**：数据库存储通常依赖于磁盘I/O操作，而磁盘读写速度远低于内存操作。B+Tree通过减少树的高度，减少了访问磁盘的次数，从而优化了查询性能。

### 3. B+Tree vs Hash

- **支持范围查询**：Hash索引擅长处理等值查询，但是不支持范围查询。B+Tree索引能够非常高效地处理范围查询，这是数据库索引中一个常见且重要的需求。
- **良好的动态扩展性**：Hash索引在处理大量冲突时可能会遇到性能下降的问题，尤其是当数据集大小变化较大时。B+Tree通过平衡操作，保持了良好的性能，即使在数据量大幅增减的情况下也能保持较高的效率。

## 什么时候创建索引

### 何时需要创建索引

1. **频繁作为查询条件的列**：如果某个列经常出现在WHERE子句中，为这个列创建索引可以加快查询速度。
2. **作为连接的键**：在进行表连接操作时，对连接键创建索引可以显著提高效率。
3. **具有高选择性的列**：列的选择性是指不同值的比例。选择性高意味着列中的值几乎或完全唯一，这样的列上创建索引效果最好。
4. **排序和分组的列**：经常用于ORDER BY、GROUP BY子句的列上创建索引，可以提高排序和分组操作的速度。
5. **作为外键的列**：为外键创建索引可以加快关联表的增删查改操作。
6. **使用范围查询的列**：对于那些经常进行范围查询的列，创建索引可以提高查询效率。

### 何时不需要创建索引

1. **数据量小的表**：对于数据量非常小的表，索引可能不会带来查询性能的提升，因为全表扫描的速度已经足够快。
2. **经常进行大批量更新或插入操作的列**：索引可以加快查询速度，但会降低写操作的速度。如果某个列的数据经常变动，那么维护索引将消耗大量资源。
3. **数据重复率高的列**：如果某个列中包含大量重复的数据，那么为这样的列创建索引效果不佳，甚至可能适得其反。
4. **只包含少数几个不同值的列**：例如性别、是否删除等字段，这些字段的选择性很低，创建索引的效果有限。

### 综合考虑

- **空间和性能权衡**：创建索引虽然可以提高查询效率，但同时也需要消耗额外的磁盘空间，并且会增加数据库的维护成本，如索引的重建和更新。
- **查询与更新的平衡**：需要在查询效率提升与更新操作成本之间找到平衡点。如果一个系统的写操作远多于读操作，那么过多的索引可能会导致性能下降。

## 怎么优化索引

1. 使用合适的索引类型

- **选择合适的索引类型**，如B+树索引、全文索引、哈希索引等，根据数据的特点和查询需求选择最合适的索引类型。

2. 索引列的选择

- **为经常出现在WHERE子句、JOIN条件、ORDER BY和GROUP BY子句中的列创建索引**。
- **避免在数据变动大的列上创建索引**，如频繁更新的字段。
- **为具有高数据唯一性的列创建索引**。高唯一性意味着索引能更有效地过滤数据。

3. 使用复合索引

- **合理使用复合索引**，即在多个列上创建单个索引，尤其当查询条件中经常同时包含这些列时。复合索引的顺序应根据查询条件的频率和列的选择性来确定。

4. 索引维护

- **定期检查并移除无用或重复的索引**，以减少维护成本和提高写操作的性能。
- **使用索引分析工具**，定期分析索引的使用情况，优化或重建碎片化的索引，确保索引效率。

5. 覆盖索引

- **利用覆盖索引**，即查询列直接在索引中，可以避免访问表数据，减少I/O操作。

6. 索引预测和测试

- **在更改索引前进行预测和测试**。在开发环境中模拟索引更改，评估其对查询性能的影响。

7. 分区表的索引优化

- **对于大表，考虑使用表分区**，并为各个分区创建本地索引。这样可以限制查询在特定分区内搜索，进一步提高查询效率。

8. 考虑索引的存储成本

- **权衡索引的存储成本和性能收益**。尽管索引可以加速查询，但过多的索引会增加存储成本，并且降低写操作的速度。

9. 使用最新的数据库特性

- **利用数据库管理系统的最新特性**，如MySQL的InnoDB存储引擎提供的自动索引优化特性。

## MySQL 单表不要超过 2000W 行，靠谱吗？

- MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。
- 页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。
- 在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。
- 索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。

## 索引失效

1. 使用左模糊或双向模糊匹配

- 当使用`LIKE`关键字进行模糊匹配查询时，如果模式以通配符开始（如`%xx`或`%xx%`），数据库无法利用索引进行查找，因为这要求数据库扫描全表来匹配模式。

2. 在索引列上使用函数

- 如果查询条件中在索引列上使用了函数（如`YEAR(column)`），数据库需要对每一行的对应列计算函数结果，这样就无法直接利用索引。

3. 在索引列上进行表达式计算

- 当查询条件中对索引列进行了计算（例如`column + 1`），这会导致数据库无法直接利用索引，因为它需要对每一行的数据计算表达式的值。

4. 字符串和数字的隐式类型转换

- 当字符串类型的索引列与数字进行比较时（如`column = 123`），MySQL会将字符串转换为数字进行比较，这种隐式的类型转换会导致索引失效。

5. 联合索引的最左前缀原则

- 对于联合索引，只有遵循最左前缀原则时，索引才会被有效使用。也就是说，查询条件需要从联合索引的最左边的列开始，并且按照索引中的列的顺序进行。

6. 在`WHERE`子句中使用`OR`导致的索引失效

- 如果`WHERE`子句中使用了`OR`，并且`OR`前的条件列是索引列，而`OR`后的条件列不是索引列，那么对索引列的查询就会失效。

## MySQL 使用 like “%x“，索引一定会失效吗？

如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。 