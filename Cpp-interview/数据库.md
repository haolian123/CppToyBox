## 基本概念

___

- **数据（Data）**：描述事物的符号记录。
- **数据库（DataBase, DB）**：长期存储在计算机内、有组织的、可共享的大量数据的集合。特点包括永久存储、有组织、可共享。
- **数据库管理系统（DataBase Management System, DBMS）**：位于用户与操作系统之间的一层数据管理软件。
- **数据库系统（DataBase System, DBS）**：由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator, DBA）组成，用于存储、管理、处理和维护数据的系统。
- **实体（Entity）**：客观存在并可相互区别的事物。
- **属性（Attribute）**：实体所具有的某一特性。
- **码（Key）**：唯一标识实体的属性集。
- **实体型（Entity Type）**：用实体名及其属性名集合来抽象和刻画同类实体。
- **实体集（Entity Set）**：同一实体型的集合。
- **联系（Relationship）**：指不同实体集之间的联系。
- **模式（Schema）**：数据库全体数据的逻辑结构和特征的描述，所有用户的公共数据视图。
  - **外模式（External Schema）**：数据库用户能看见和使用的局部数据的逻辑结构和特征的描述，与某一应用有关的数据的逻辑表示。
  - **内模式（Internal Schema）**：一个数据库的数据物理结构和存储方式的描述，数据库在内部的组织方式。

## 常用数据模型

___

### 层次模型（Hierarchical Model）
- **描述**：数据以树状结构组织，每个记录只有一个父节点，但可以有多个子节点。
- **示例**：组织结构图。公司的结构可以被表示为一个层次模型，其中CEO是根节点，下面是各个部门经理，再下面是员工。

### 网状模型（Network Model）
- **描述**：类似于层次模型，但每个记录可以有多个父节点和多个子节点。
- **示例**：交通运输网络。城市可以是节点，交通运输路线可以是节点之间的连接，每个城市（节点）可以通过多条路线（连接）与其他城市相连。

### 关系模型（Relational Model）
- **描述**：数据以表格的形式存储，表由行（元组）和列（属性）组成。
- **示例**：学生信息表。一个表格包含学生ID、姓名、年龄和班级，每个学生是一行，每个特征（如姓名）是一列。
  - **关系（Relation）**：学生信息表
  - **元组（Tuple）**：表中的一行，例如学生 "John Doe"
  - **属性（Attribute）**：表中的一列，例如 "姓名"
  - **码（Key）**：唯一确定一个元组的属性组，例如学生ID
  - **域（Domain）**：一组具有相同数据类型的值的集合，例如所有可能的学生姓名
  - **分量**：元组中的一个属性值，例如 "John Doe" 中的 "John"
  - **关系模式**：关系的描述，例如 学生(学生ID, 姓名, 年龄, 班级)

### 面向对象数据模型（Object Oriented Data Model）
- **描述**：数据和行为被封装在对象中，对象可以是现实世界实体的表示。
- **示例**：图书馆系统。每本书可以是一个对象，属性包括标题、作者和ISBN，行为可以包括借出和归还。

### 对象关系数据模型（Object Relational Data Model）

- **描述**：结合了关系模型和对象模型的特点，支持对象的概念，如继承、多态和封装。
- **示例**：员工管理系统。除了基本的员工信息（作为关系模型的一部分），还可以有对象表示员工的技能和资历，这些对象与员工对象相关联。

### 半结构化数据模型（Semistructure Data Model）
- **描述**：不需要固定的模式，数据结构可能是不规则或不完整的。
- **示例**：JSON或XML文档。例如，一个产品的JSON记录可以有价格、描述和可选字段，如尺寸或颜色，而这些字段并不在每个记录中都出现。

## SQL 操作

___

在数据库管理中，SQL (Structured Query Language) 是用于管理关系数据库的标准编程语言。以下是对常用 SQL 操作的详细说明和相应的示例。

### 数据库模式（Schema）

- **创建模式**：用于定义数据库的逻辑结构。
  
  ```sql
  -- 创建一个名为 'StudentDB' 的模式
  CREATE SCHEMA StudentDB;
  ```

### 基本表

- **创建表**：用于定义数据的结构，即表中的列和数据类型。
  
  ```sql
  -- 在 'StudentDB' 模式下创建一个名为 'Students' 的表
  CREATE TABLE StudentDB.Students (
      StudentID INT PRIMARY KEY,
      Name VARCHAR(100),
      Age INT,
      Major VARCHAR(100)
  );
  ```

- **修改表**：用于修改现有表的结构，如添加或删除列。
  
  ```sql
  -- 在 'Students' 表中添加一个名为 'GPA' 的列
  ALTER TABLE StudentDB.Students
  ADD GPA DECIMAL(3, 2);
  ```

### 视图（View）

- **创建视图**：视图是可查询的虚拟表，通常用于简化复杂的查询，不直接包含数据，但提供数据的一种视角。
  
  ```sql
  -- 创建一个名为 'View_StudentInfo' 的视图，展示学生的ID和姓名
  CREATE VIEW StudentDB.View_StudentInfo AS
  SELECT StudentID, Name
  FROM StudentDB.Students;
  ```

### 索引（Index）

- **创建索引**：索引用于加快对数据表中的数据检索速度。下面是在 `Name` 列上创建索引的示例。
  
  ```sql
  -- 在 'Students' 表的 'Name' 列上创建一个索引
  CREATE INDEX idx_name
  ON StudentDB.Students (Name);
  ```

### 数据

对于基本表和视图的常见操作包括查询、插入、更新和删除数据：

- **查询（SELECT）**
  
  ```sql
  -- 查询 'Students' 表中所有记录
  SELECT * FROM StudentDB.Students;
  
  -- 查询 'Students' 表中姓名为 'John Doe' 的学生信息
  SELECT * FROM StudentDB.Students
  WHERE Name = 'John Doe';
  ```

- **插入（INSERT）**
  
  ```sql
  -- 向 'Students' 表中插入一条新记录
  INSERT INTO StudentDB.Students (StudentID, Name, Age, Major)
  VALUES (1, 'John Doe', 20, 'Computer Science');
  ```

- **更新（UPDATE）**
  
  ```sql
  -- 更新 'Students' 表中某学生的专业
  UPDATE StudentDB.Students
  SET Major = 'Mathematics'
  WHERE StudentID = 1;
  ```

- **删除（DELETE）**
  
  ```sql
  -- 从 'Students' 表中删除一条记录
  DELETE FROM StudentDB.Students
  WHERE StudentID = 1;
  ```

- **权限操作（GRANT, REVOKE）**
  
  ```sql
  -- 授予用户对 'Students' 表的 SELECT 权限
  GRANT SELECT ON StudentDB.Students TO some_user;
  
  -- 撤销用户对 'Students' 表的 SELECT 权限
  REVOKE SELECT ON StudentDB.Students FROM some_user;
  ```

### 属性列

对属性列的操作通常与数据操作相似，但针对特定的列：

- **查询特定列（SELECT）**
  
  ```sql
  -- 仅查询 'Students' 表中学生的姓名和专业
  SELECT Name, Major FROM StudentDB.Students;
  ```

- **更新特定列（UPDATE）**
  
  ```sql
  -- 更新 'Students' 表中某学生的年龄
  UPDATE StudentDB.Students
  SET Age = 21
  WHERE StudentID = 1;
  ```

## 关系型数据库

___

关系型数据库是基于关系模型的，使用一系列的表来存储数据及其关系。在这种模型中，表由行和列组成，每一行代表一个数据项，每一列代表一个数据字段。

### 基本关系操作

1. **查询操作**：
   
   - **选择（Selection）**：从表中选取满足特定条件的行。
     ```sql
     -- 选择所有年龄大于20的学生
     SELECT * FROM Students WHERE Age > 20;
     ```
   - **投影（Projection）**：从表中选取特定的列。
     
     ```sql
     -- 仅显示学生的姓名和年龄
     SELECT Name, Age FROM Students;
     ```
   - **连接（Join）**：将两个或多个表的行组合起来，根据一定的条件。
     - **等值连接（Equi-Join）**：基于两个表中的列的等值关系来连接表。
       ```sql
       -- 连接 Students 表和 Scores 表，基于 StudentID
       SELECT * FROM Students INNER JOIN Scores ON Students.StudentID = Scores.StudentID;
       ```
     - **自然连接（Natural Join）**：自动为你匹配和连接两个表中相同名称的列。
       ```sql
       -- 自然连接 Students 表和 Scores 表
       SELECT * FROM Students NATURAL JOIN Scores;
       ```
     - **外连接（Outer Join）**：包括 LEFT OUTER JOIN, RIGHT OUTER JOIN, 和 FULL OUTER JOIN，不仅返回符合连接条件的行，还返回左表、右表或两边表中未匹配的行。
       ```sql
       -- 左外连接，即使右表（Scores）中没有匹配，也返回左表（Students）的所有行
       SELECT * FROM Students LEFT OUTER JOIN Scores ON Students.StudentID = Scores.StudentID;
    ```
   - **除（Division）**、**并（Union）**、**差（Difference）**、**交（Intersection）**、**笛卡尔积（Cartesian Product）** 等也是关系操作的一部分，但不如上述操作常用。
   
2. **数据修改操作**：
   - **插入（Insert）**：向表中添加新行。
     ```sql
     -- 向 Students 表中插入一条记录
     INSERT INTO Students (StudentID, Name, Age, Major) VALUES (1, 'John Doe', 20, 'Computer Science');
     ```
   - **删除（Delete）**：从表中删除行。
     ```sql
     -- 从 Students 表中删除年龄大于 22 的所有学生
     DELETE FROM Students WHERE Age > 22;
     ```
   - **修改（Update）**：更新表中的现有行。
     ```sql
     -- 更新 Students 表中的学生，将名为 John Doe 的学生的专业修改为 'Mathematics'
     UPDATE Students SET Major = 'Mathematics' WHERE Name = 'John Doe';
     ```

### 关系模型完整性约束

1. **实体完整性**：确保每个表的主键都是唯一的，且不包含 NULL 值。
   - 例如，在创建表时定义主键：
     ```sql
     CREATE TABLE Students (
         StudentID INT PRIMARY KEY,
         Name VARCHAR(100),
         Age INT
     );
     ```

2. **参照完整性**：确保一个表中的外键值必须在另一个表的主键中有对应的值或者是 NULL。
   - 例如，如果有一个 Scores 表，其中包含一个指向 Students 表的外键：
     ```sql
     CREATE TABLE Scores (
         ScoreID INT PRIMARY KEY,
         StudentID INT,
         Score INT,
         FOREIGN KEY (StudentID) REFERENCES Students(StudentID)
     );
     ```

3. **用户定义的完整性**：满足特定业务规则的约束。
   
   - 例如，确保学生的年龄不能小于 18：
     ```sql
     ALTER TABLE Students
     ADD CONSTRAINT chk_Age CHECK (Age >= 18);
     ```

## 索引

___

​	索引是数据库中的一种数据结构，可以提高数据检索的速度。就像书籍末尾的索引一样，数据库索引帮助数据库服务器快速定位存储在数据表中的数据。

### 数据库索引类型

1. **顺序索引（Sequential Index）**：
   - **描述**：顺序索引是在数据的物理存储顺序上构建的索引。是基于表中数据的自然顺序。
   - **适用场景**：适用于经常需要按顺序检索的数据。
   - **示例**：图书馆的书籍编号，通常按照书籍的编号顺序存放。

2. **B+ 树索引（B+ Tree Index）**：
   - **描述**：B+ 树索引是一种自平衡的树结构，在关系型数据库中广泛使用。每个非叶节点代表了其子节点中的最大（或最小）值。叶节点包含了指向数据的指针。
   - **适用场景**：适用于大量数据的快速检索，插入，删除操作。尤其是在需要范围查询和有序遍历时。
   - **示例**：在一个用户数据库中，可能会基于用户的ID或用户名建立 B+ 树索引以快速检索用户信息。

3. **Hash 索引（Hash Index）**：
   - **描述**：Hash 索引使用哈希表来存储数据。每个数据项通过哈希函数映射到一个特定的位置。
   - **适用场景**：适用于等值查询，比如在键值对数据结构中快速找到特定的值。
   - **示例**：在一个密码数据库中，为了快速验证用户登录，系统可能会对用户密码进行哈希处理，并在登录时比对哈希值。

### 深入理解 MySQL 索引

MySQL中的索引通常使用 B+ 树索引。这里对 B+ 树索引背后的数据结构及算法原理进行深入解析：

- **B+ 树的结构**：
  - B+ 树是一种多路平衡查找树，的每个节点最多可以包含 k 个孩子（k-1 个关键字）。B+ 树中的所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，叶子节点之间通过指针相互链接。
  - 非叶节点（内部节点）存储的是键值，用于指导搜索方向，实际的数据记录存储在叶子节点中。
  
- **B+ 树的优势**：
  - **查询速度稳定**：B+ 树的所有查询都需要从根节点到叶节点，查询性能稳定。
  - **全键值遍历更快**：由于叶子节点包含了全部键值信息且相互链表，便于对全体数据进行遍历。
  - **范围查询方便**：B+ 树支持范围查找和排序查找，能够快速找到指定范围的所有数据。
  
- **索引维护**：
  - 当数据表中的数据发生变化时（如INSERT, DELETE, UPDATE操作），索引也需要随之更新，保持数据与索引的一致性。
  - 虽然索引能极大地提高查询速度，但同时也会稍微减慢数据的插入、删除和修改操作，因为在进行这些操作时，数据库系统还需要维护索引的结构。

###  示例

假设有一个学生表 `Students`，其中包含学生的ID，姓名和年龄。如果经常根据学生的姓名来检索信息，可能会为 `Name` 列建立一个索引：

```sql
CREATE INDEX idx_name ON Students (Name);
```

在这个例子中，如果使用 B+ 树索引，数据库会根据学生的姓名构建一个 B+ 树。当执行一个查询，比如查找名为 "John Doe" 的学生时：

```sql
SELECT * FROM Students WHERE Name = 'John Doe';
```

数据库可以使用索引来快速定位到名为 "John Doe" 的学生的记录，而不需要扫描整个 `Students` 表，从而显著提高查询效率。

### 顺序索引 vs B+ 树索引 vs Hash 索引

#### 速度：

- **顺序索引**：
  - 查询速度：适用于有序数据的顺序访问。在最好情况下（数据已排序），顺序扫描速度很快。但如果要查询的数据分布广泛，则可能需要遍历整个索引。
  
- **B+ 树索引**：
  - 查询速度：对于范围查询和有序数据访问非常快。B+ 树索引对于等值查询和范围查询都能提供良好的性能，因为们都是基于树的结构，允许快速的数据定位和有序访问。
  
- **Hash 索引**：
  - 查询速度：对于等值查询（例如精确查找）非常快，因为直接将键映射到表中的位置。但对于范围查询则不是很适用。

#### 适用场景：

- **顺序索引**：
  - 主要适用于那些经常需要按顺序访问数据的场景。如果数据自然排序，并且查询经常涉及大量连续的记录，则顺序索引非常高效。
  
- **B+ 树索引**：
  - 适用于大量数据的环境，并且需要支持多种类型的查询，包括等值查询、范围查询和排序操作。是大多数数据库系统的默认索引类型。

- **Hash 索引**：
  - 适用于快速等值查询，例如键值查找。在只有精确匹配条件的查询中表现最好。

#### 特点：

- **顺序索引**：
  - 简单，容易实现。
  - 对于有序数据或者顺序访问非常高效。
  - 不适合频繁修改的数据，因为插入和删除操作可能需要大量的数据移动。
  
- **B+ 树索引**：
  - 所有记录节点都存放在叶子节点上，非叶节点只存储键值信息，因此更稳定。
  - 支持顺序访问和快速查找。
  - 由于树的平衡特性，插入和删除操作可以在对数时间内完成，即使是大量数据也是如此。
  
- **Hash 索引**：
  - 提供非常快速的查询响应，特别是对于等值查询。
  - 不支持范围查询和排序操作。
  - 哈希冲突可能会影响性能，特别是在负载较高的情况下。

## 数据库完整性与安全性

___

- **完整性**
  - 数据的正确性和相容性的保证。
  - 防止数据库中存在不符合语义（不正确）的数据。
- **安全性**
  - 保护数据库防止恶意破坏和非法存取。
- **触发器**
  - 用户定义在关系表中的一类由事件驱动的特殊过程。

## 关系数据理论

___

数据库的完整性和安全性是维护数据质量和保护数据不受不当访问的重要方面。

### 完整性 (Integrity)

- **定义**：数据库完整性确保数据的准确性和一致性。防止了数据被不正确地修改，无论是由于系统错误、人为错误还是设计缺陷。
  
- **类型**：
  
  - **实体完整性**：确保每个表都有一个唯一的标识符，如主键，且主键列不能有 NULL 值。
  - **参照完整性**：确保表之间的关系保持一致，即外键值必须在相关表的主键中有对应值或者是 NULL。
- **用户定义完整性**：确保数据符合业务规则，如数据范围、格式和逻辑约束。
  
- **示例**：
  - **实体完整性示例**：
    ```sql
    -- 创建学生表，确保每个学生都有唯一的学生ID
    CREATE TABLE Students (
        StudentID INT PRIMARY KEY,
        Name VARCHAR(100),
        Age INT
    );
    ```
  - **参照完整性示例**：
    ```sql
    -- 创建成绩表，确保成绩表中的学生ID与学生表中的学生ID相对应
    CREATE TABLE Grades (
        GradeID INT PRIMARY KEY,
        StudentID INT,
        Grade CHAR(1),
        FOREIGN KEY (StudentID) REFERENCES Students(StudentID)
    );
    ```
  - **用户定义完整性示例**：
    ```sql
    -- 确保学生的年龄在合理的范围内
    ALTER TABLE Students
    ADD CONSTRAINT chk_Age CHECK (Age >= 5 AND Age <= 18);
    ```

### 安全性 (Security)

- **定义**：数据库安全性是指保护数据免受未经授权的访问和修改。包括用户身份验证、授权、数据加密和审计等机制。
  
- **措施**：
  - **用户身份验证**：确认用户的身份，例如通过用户名和密码。
  - **访问控制**：限制用户对数据库对象的访问，例如通过角色和权限。
  - **数据加密**：加密存储在数据库中的数据，确保即使数据被盗也难以解读。
  - **审计**：记录和审查数据库操作，以检测和防止不当行为或潜在的安全问题。

- **示例**：
  - **授予权限示例**：
    
    ```sql
    -- 授予用户对学生表的 SELECT 和 UPDATE 权限
    GRANT SELECT, UPDATE ON Students TO some_user;
    ```
  - **撤销权限示例**：
    ```sql
    -- 撤销用户对成绩表的所有权限
    REVOKE ALL PRIVILEGES ON Grades FROM some_user;
    ```

### 触发器 (Trigger)

- **定义**：触发器是数据库中的一种特殊类型的存储过程，会在特定事件发生时自动执行，如对表进行 INSERT、UPDATE 或 DELETE 操作时。
  
- **用途**：
  - 自动执行检查或更新数据的操作。
  - 维护数据库完整性。
  - 记录数据变更的历史。

- **示例**：
  - **创建触发器示例**：
    ```sql
    -- 创建一个触发器，在向学生表插入新记录时自动记录时间
    CREATE TRIGGER trg_AfterInsert
    AFTER INSERT ON Students
    FOR EACH ROW
    BEGIN
       INSERT INTO Audit(StudentID, Operation, OperationTime)
       VALUES (NEW.StudentID, 'INSERT', NOW());
    END;
    ```

在这个示例中，`trg_AfterInsert` 触发器会在向 `Students` 表插入新记录之后自动执行。会在 `Audit` 表中插入一个新记录，记录新插入的学生ID、操作类型（INSERT）以及操作发生的时间。

## 数据库范式

___

### 范式（Normalization）
数据库设计的核心目标是确保数据的一致性和完整性。范式是达成这一目标的规则集合。
- **第一范式 (1NF)**：属性是最小单位，不可再分。
- **第二范式 (2NF)**：满足 1NF，且每个非主属性完全依赖于主键（消除非主属性对码的部分函数依赖）。
- **第三范式 (3NF)**：满足 2NF，且任何非主属性不依赖于其他非主属性（消除非主属性对码的传递函数依赖）。
- **鲍依斯-科得范式 (BCNF)**：满足 3NF，且任何非主属性不能对主键子集依赖（消除主属性对码的部分和传递函数依赖）。
- **第四范式 (4NF)**：满足 3NF，且属性之间不能有非平凡且非函数依赖的多值依赖（消除非平凡且非函数依赖的多值依赖）。

## 数据库恢复

___

​	数据库恢复是数据管理中的一个重要方面，它确保在系统故障、硬件故障、用户错误或其他异常情况下，数据可以被正确地恢复到某个一致的状态。

### 事务和 ACID 特性

- **定义**：事务是一系列操作，这些操作要么全部执行，要么全部不执行。事务是数据库完整性的关键。

- **ACID 特性**：
  - **原子性（Atomicity）**：确保事务中的所有操作要么全部完成，要么全部不发生。即使在系统故障时，事务的原子性也得到保障。
  - **一致性（Consistency）**：确保每次事务都将数据库从一个一致的状态转换到另一个一致的状态。
  - **隔离性（Isolation）**：确保并发运行的事务不会互相干扰。
  - **持久性（Durability）**：确保事务一旦提交，其结果就是永久性的，即使系统发生故障也不会丢失。

### 数据库恢复的实现技术

1. **数据转储**：
   - **动态海量转储（Dynamic Full Dumping）**：在系统运行时定期将整个数据库复制到备份介质。
   - **动态增量转储（Dynamic Incremental Dumping）**：仅将自上次转储以来已修改的数据复制到备份介质。
   - **静态海量转储（Static Full Dumping）**：在系统关闭时，将整个数据库复制到备份介质。
   - **静态增量转储（Static Incremental Dumping）**：在系统关闭时，仅将自上次转储以来已修改的数据复制到备份介质。

2. **登记日志文件**：
   - **定义**：数据库的每次变更都会在日志文件中记录下来，包括开始事务、修改数据和结束事务的信息。
   - **作用**：在数据库发生故障时，可以使用日志文件来恢复被损坏或丢失的数据。日志文件的使用通常分为以下两个步骤：
     - **回滚（Undo）**：取消未完成的事务。如果系统故障时有事务未完成，日志文件会被用来撤销这些事务所做的所有修改。
     - **重做（Redo）**：重新应用已完成的事务。即使在系统故障后，也保证已提交的事务所做的修改不会丢失。

### 示例

假设有一个简单的银行数据库，其中有一个 `Accounts` 表，用于存储客户的账户信息。考虑以下的转账事务：

```sql
-- 转账事务
BEGIN TRANSACTION;

-- 从账户 A 扣除 100 美元
UPDATE Accounts SET balance = balance - 100 WHERE account_id = 'A';

-- 给账户 B 增加 100 美元
UPDATE Accounts SET balance = balance + 100 WHERE account_id = 'B';

COMMIT;
```

这个事务包含两个操作：从账户 A 中扣除金额，并向账户 B 中增加相同的金额。这个事务要么完全执行（如果两个 `UPDATE` 操作都成功），要么完全不执行（如果任一 `UPDATE` 操作失败），以此保证数据库的一致性。

如果在执行事务过程中发生系统崩溃，数据库的恢复机制会利用日志文件来确定哪些操作需要撤销，哪些需要重做。例如，如果上述事务在提交之前系统崩溃了，恢复机制会回滚事务，确保账户 A 和账户 B 的余额保持不变。如果事务已经提交，那么即使系统崩溃，转账操作也会被保留，保证了事务的持久性。

## 并发控制

___

在数据库系统中，当多个事务同时运行时，可能会试图同时访问和修改相同的数据。并发控制是数据库管理系统（DBMS）用来确保数据一致性和事务隔离性的一套机制和策略。

### 并发操作带来的问题

在没有适当并发控制的情况下，可能会出现以下问题：

1. **丢失修改（Lost Update）**：
   - 情景：两个事务同时修改同一条记录。一个事务的更新可能被另一个事务的更新覆盖。
   - 示例：两个银行柜员同时更新同一个账户的余额。一个柜员的更新会丢失，因为另一个柜员的更新覆盖了它。

2. **不可重复读（Non-repeatable Read）**：
   - 情景：一个事务在读取某些数据后，另一个事务修改了这些数据。当第一个事务再次读取相同的数据时，会发现数据已经改变。
   - 示例：一个事务读取了员工的工资，而另一个事务在此期间增加了该员工的工资。当第一个事务再次读取工资时，发现工资已变化。

3. **读“脏”数据（Dirty Read）**：
   - 情景：一个事务读取了另一个未提交事务修改的数据。如果那个未提交的事务最终回滚，第一个事务就读取了永远不会被提交的数据。
   - 示例：一个事务读取了另一个事务修改的账户余额，但那个修改的事务最终失败并回滚。这意味着第一个事务读取了一个无效的余额。

### 并发控制技术

为了解决上述问题，数据库系统实现了多种并发控制技术：

1. **封锁（Locking）**：
   - 排他锁（X 锁 / 写锁）：确保当一个事务在修改数据时，其他事务不能同时修改或读取同一数据。
   - 共享锁（S 锁 / 读锁）：允许多个事务同时读取同一数据，但在共享锁持有期间，数据不能被修改。

2. **时间戳**：
   - 每个事务被赋予一个唯一的时间戳。系统根据时间戳来决定事务的优先级，以解决数据访问冲突。

3. **乐观控制法（Optimistic Concurrency Control）**：
   - 假设事务之间的冲突很少发生，事务在提交前不会被封锁。在提交时，系统检查是否存在冲突，如果存在，则事务被回滚。

4. **多版本并发控制（MVCC）**：
   - 同时维护数据的多个版本，以支持读操作和写操作的并发性。这通常用于实现不可重复读和幻读问题的解决方案。

### 活锁和死锁

在并发控制中，还可能出现活锁和死锁的问题：

1. **活锁**：
   - 事务永远处于等待状态，因为它们不断地重复相同的冲突解决策略，而没有进展。
   - **预防策略**：实施**先来先服务**策略，确保事务以一定的顺序执行。

2. **死锁**：
   - 两个或多个事务相互等待对方释放锁，造成系统停滞不前。
   - **预防和解除策略**：
     - **一次封锁法**：事务开始时一次性获取所有需要的锁。
     - **顺序封锁法**：事务必须按照一定的顺序获取锁。
     - **超时法**：事务等待锁的时间超过某个阈值时，就放弃，回滚事务。
     - **等待图法**：数据库系统维护一个等待图，用以检测和解决死锁。
     - **解除策略**：当检测到死锁时，选择并撤销处理死锁代价最小的事务，并释放其所有锁。

### 示例：银行转账并发控制

考虑两个并发事务，一个是从账户 A 向账户 B 转账，另一个是从账户 B 向账户 C 转账：

- **事务 1**：
  - `BEGIN TRANSACTION;`
  - `SELECT balance FROM Accounts WHERE account_id = 'A';`
  - `UPDATE Accounts SET balance = balance - 100 WHERE account_id = 'A';`
  - `UPDATE Accounts SET balance = balance + 100 WHERE account_id = 'B';`
  - `COMMIT;`

- **事务 2**：
  - `BEGIN TRANSACTION;`
  - `SELECT balance FROM Accounts WHERE account_id = 'B';`
  - `UPDATE Accounts SET balance = balance - 50 WHERE account_id = 'B';`
  - `UPDATE Accounts SET balance = balance + 50 WHERE account_id = 'C';`
  - `COMMIT;`

在没有适当并发控制的情况下，两个事务可能会相互影响，导致不可预知的结果，如丢失修改。使用封锁或其他并发控制技术可以确保每个事务都在一个隔离的环境中执行，从而维护数据库的一致性和隔离性。

## 可串行化调度

___

在数据库系统中，可串行化（Serializability）是并发控制的最高标准。它确保当多个事务并发执行时，最终的结果与这些事务按某个顺序依次执行（串行执行）时的结果相同。这种性质是数据库并发控制的核心，旨在保证数据的一致性和完整性。

### 可串行化调度的定义

- **定义**：可串行化调度是指，多个事务的并发执行结果等同于它们以某种顺序串行执行的结果。这意味着事务的执行虽然是并发的，但从逻辑上看，**它们的执行效果与按某个顺序一个接一个执行相同。**

### 可串行化的重要性

- **数据一致性**：确保即使在并发环境下，数据也保持一致状态，没有冲突和异常。
- **事务隔离**：即使多个事务同时运行，每个事务也好像是在独立运行，不受其他事务的影响。
- **系统可靠性**：通过确保并发事务的可串行化，数据库系统提供了对数据一致性和完整性的强保障。

### 可串行化的实现

实现可串行化的主要方法是通过各种并发控制协议，如两阶段锁定协议（2PL）和时间戳排序协议。这些协议通过控制事务对数据项的访问来确保可串行化：

1. **两阶段锁定协议（2PL）**：在事务的生命周期中分为两个阶段对数据项进行加锁和解锁。第一阶段是加锁阶段，事务可以获得锁但不能释放任何锁；第二阶段是解锁阶段，事务释放所有锁但不能获得新的锁。
2. **时间戳排序协议**：给每个事务分配一个唯一的时间戳。系统根据时间戳来决定事务的执行顺序，从而保证事务的可串行化。
