# TCP

## TCP为什么要三次握手

1. **能防止历史连接的建立**
2. **能减少双方不必要的资源开销**
3. **能帮助双方同步初始化序列号**。

___

### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样

1. 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
2. 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；

___

## 握手丢失

### 第一次握手丢失

- 当客户端超时重传 3 次 SYN 报文后，由于 tcp_syn_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。

### 第二次握手丢失

- 当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。
- 当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

### 第三次握手丢失

- 当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

注意：ACK报不会主动重传。

___

## 避免SYN攻击

1. 调大 netdev_max_backlog（数据包队列）；
   - 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，适当调大该参数的值，比如设置为 10000
2. 增大 TCP 半连接队列；
3. 开启 tcp_syncookies；
   - 当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 `cookie` 值；
   - 将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；
   - 服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。
   - 最后应用程序通过调用 `accpet()` 接口，从「 Accept 队列」取出的连接。
4. 减少 SYN+ACK 重传次数
   - 那么针对 SYN 攻击的场景，可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

___

## TCP为什么要四次挥手

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

___

## 挥手丢失

### 第一次挥手丢失

- 当客户端超时重传 3 次 FIN 报文后，由于 tcp_orphan_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。

### 第二次挥手丢失

- 当客户端超时重传 2 次 FIN 报文后，由于 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。

### 第三次挥手丢失

- 当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。
- 客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。

### 第四次挥手丢失

- 当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。
- 客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。

___

## 第三次挥手后的TIME_WAIT状态

### 为什么需要TIME_WAIT

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
- 保证「被动关闭连接」的一方，能被正确的关闭；

### 为什么TIME_WAIT等待时间是2MSL

- `MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
- 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

### TIME_WAIT过多有什么危害

- 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
- 第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 `32768～61000`，也可以通过 `net.ipv4.ip_local_port_range`参数指定范围。

### 如何优化TIME_WAIT

1. **开启 `net.ipv4.tcp_tw_reuse` 和 `net.ipv4.tcp_timestamps`**：
   - 这就像是你在会议室里安装了一个自动检测系统，当检测到会议室已经清空超过一定时间，并且没有遗留的物品或垃圾时，就可以立即重新使用。这样可以提高会议室的使用效率，但需要确保检测系统准确无误，否则可能会有未清理干净的情况。
2. **调整 `net.ipv4.tcp_max_tw_buckets` 的值**：
   - 这相当于设置一个规则，无论会议室的使用和清理情况如何，每天最多只允许有一定数量的会议进行。一旦超过这个数量，会议清理过程会被强行结束。这种做法虽然能防止资源过度占用，但可能会导致某些会议室清理不彻底。
3. **使用 `SO_LINGER` 选项强制使用 `RST` 关闭**：
   - 这就像是会议一结束就立刻清空会议室，不等人完全离开就开始清理。虽然这可以迅速让会议室准备好迎接下一场会议，但如果清理过于仓促，可能会忽略一些重要的清理步骤，如确保所有设备安全、资料归位等，有时甚至可能导致后续使用者的不便。

### 服务器出现大量 TIME_WAIT 状态的原因有哪些？

- 第一个场景：HTTP 没有使用长连接
- 第二个场景：HTTP 长连接超时
- 第三个场景：HTTP 长连接的请求数量达到上限

### 服务器出现大量 CLOSE_WAIT状态的原因有哪些？

- 当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

- 定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

### 如果已经建立了连接，但是服务端的进程崩溃会发生什么？

- TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。

___

## 基于TCP的Socket编程

### Socket编程过程

- 服务端和客户端初始化 `socket`，得到文件描述符；
- 服务端调用 `bind`，将 socket 绑定在指定的 IP 地址和端口;
- 服务端调用 `listen`，进行监听；
- 服务端调用 `accept`，等待客户端连接；
- 客户端调用 `connect`，向服务端的地址和端口发起连接请求；
- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；
- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；
- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。

### listen时候backlog的意义

```c
int listen (int socketfd, int backlog)
```

- 参数一 socketfd 为 socketfd 文件描述符
- 参数二 backlog，这参数在历史版本有一定的变化

在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。

在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，**所以现在通常认为 backlog 是 accept 队列。**

### accept发生在三次握手的哪一步

客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。

### 客户端调用close后断开的流程是什么

- 客户端调用 `close`，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；
- 服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 `EOF` 到接收缓冲区中，应用程序可以通过 `read` 调用来感知这个 FIN 包。这个 `EOF` 会被**放在已排队等候的其他已接收的数据之后**，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；
- 接着，当处理完数据后，自然就会读到 `EOF`，于是也调用 `close` 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；
- 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；
- 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；
- 客户端经过 `2MSL` 时间之后，也进入 CLOSE 状态；

### 没有accpet还能建立TCP链接吗

答案：**可以的**。

accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

### 没有listen能建立TCP连接吗

答案：**可以的**。

客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（**TCP同时打开**），这两个情况都有个共同点，就是**没有服务端参与，也就是没有 listen，就能 TCP 建立连接。**

___

## TCP重传机制

### 超时重传

- 如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**
- 也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**
- 超时触发重传存在的问题是，超时周期可能相对较长。

### 快速重传

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- **发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。**
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

总结

- 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
- 快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是**重传的时候，是重传一个，还是重传所有的问题。**

### SACK方法

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

### D-SACK

其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

___

## TCP滑动窗口

滑动窗口是TCP协议中用以提高数据传输效率的一种机制。在只允许发送一个数据包并等待确认应答的传统模式中，通信效率受限于数据包的往返时间。滑动窗口机制通过允许发送方在等待确认的同时继续发送多个数据包来解决这一问题。窗口大小，即缓存区的大小，决定了可以连续发送而无需等待确认的数据量。发送方的窗口分为已发送且已确认、已发送未确认、未发送但可发送、及未发送且不可发送几部分。接收方通过指定窗口大小告知发送方其可接收的最大数据量。此机制确保数据传输连续性和效率，尤其是在高延迟环境中。

___

## TCP流量控制

TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

___

## TCP拥塞控制

主要依靠四种基本算法：慢启动、拥塞避免、快速重传和快速恢复。慢启动和拥塞避免共同使用拥塞窗口（cwnd）来逐渐增加网络上的数据流量，直到发生丢包为止。发生丢包时，TCP 判定网络出现拥塞，于是减小拥塞窗口大小，降低发送速率。快速重传和快速恢复算法则在检测到丢包时快速响应，通过立即重传丢失的包和调整拥塞窗口来快速恢复数据传输。这些算法协同工作，帮助TCP在各种网络状态下维持稳定和高效的数据传输。

### 慢启动

1. 当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。
2. 有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量。
   - 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
   - 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。

### 拥塞避免算法

1. 一般来说 `ssthresh` 的大小是 `65535` 字节。
2. 那么进入拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**
3. 接上前面的慢启动的栗子，现假定 `ssthresh` 为 `8`：
   - 当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 `MSS` 大小的数据，变成了**线性增长。**

### 拥塞发生

#### 超时重传

这个时候，ssthresh 和 cwnd 的值会发生变化：

- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

#### 快速重传(快速恢复)

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：

- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`(已经cwnd/2的值);
- 进入快速恢复算法

___

## TCP半连接队列和全连接队列

### 定义

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；

服务端收到客户端发起的 SYN 请求后，**内核会把该连接存储到半连接队列**，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，**内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。**

### TCP 全连接队列溢出

1. 当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接
2. 当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。
3. 如果持续不断地有连接因为 TCP 全连接队列溢出被丢弃，就应该调大 backlog 以及 somaxconn 参数。

### TCP 半连接队列溢出

1. **增大队列大小**：通过调整内核参数，比如 `tcp_max_syn_backlog`，可以增加 SYN 半连接队列的容量，从而容纳更多等待处理的连接。
2. **启用 SYN Cookies**：当队列溢出时，启用 `tcp_syncookies` 参数允许内核发送一个特殊的 SYN+ACK 响应，其中不需要保持状态信息。这样，即使 SYN 队列已满，仍然可以继续接受新的连接。当客户端响应 ACK 后，如果服务器还能匹配到该 SYN Cookie，则建立连接；否则，请求将被放弃。
3. **动态调整队列**：一些高级的 TCP 栈实现可能支持根据当前网络条件和服务器负载动态调整队列大小。

### 如何防御 SYN 攻击？

1. 增大半连接队列
2. 开启 tcp_syncookies 功能
3. 减少 SYN+ACK 重传次数
4. **部署 IDS/IPS 系统**：安装入侵检测系统（IDS）或入侵防御系统（IPS），这些系统能够识别异常流量模式并采取相应措施，如阻止来自攻击源的流量。

### 如果 SYN 半连接队列已满，只能丢弃连接吗？

1. **增大队列容量**：通过调整内核参数 `tcp_max_syn_backlog`，可以增加 SYN 半连接队列的容量，允许更多的半连接状态在队列中等待完成三次握手。
2. **启用 SYN Cookies**：通过启用 `tcp_syncookies` 参数，当队列溢出时，服务器不会真正创建 SYN 队列中的条目，而是发送一个计算出的 SYN+ACK 响应，不占用队列空间。这种方式不保存连接状态，直到客户端的 ACK 返回时才确认并建立连接。
3. **动态队列管理**：某些操作系统可能支持根据服务器当前的负载和网络状况动态调整队列的大小，以适应不同的流量条件。
4. **网络设备和解决方案**：在网络边界使用更高级的网络设备，如负载均衡器和防火墙，可以帮助管理入站连接请求，以及提前在网络边缘阻止恶意的 SYN 泛洪攻击。

___

## 如何优化TCP

### TCP三次握手

#### 客户端的优化

- **SYN包重传次数**：客户端发起连接时，SYN包的重传次数可以通过 `tcp_syn_retries` 参数控制，以应对网络不稳定情况。

#### 服务端的优化

- **半连接队列溢出**：使用 `netstat -s` 观察SYN半连接队列。若发现频繁溢出，可以通过调整 `tcp_max_syn_backlog`、`somaxconn` 和 `backlog` 参数来增大队列大小，避免新连接被丢弃。
- **SYN+ACK重传次数**：服务端回复SYN+ACK包的重传次数由 `tcp_synack_retries` 控制。
- **SYN攻击防护**：在SYN攻击下，启用 `tcp_syncookies` 参数（设为1），在SYN队列满时启用syncookie，确保正常连接的建立。
- **处理ACK包**：服务端接收到客户端的ACK后，会将连接转移到accept队列。如果队列满，系统默认行为是丢弃ACK。若将 `tcp_abort_on_overflow` 设置为1，则用RST回复客户端，通知连接建立失败。
- **Accept队列溢出**：若accept队列频繁溢出，增加 `listen` 函数的 `backlog` 参数和调整 `somaxconn` 值可以有效增大队列。队列实际长度由 `min(backlog, somaxconn)` 决定。

#### 绕过三次握手

- **TCP Fast Open (TFO)**：通过 `tcp_fastopen` 开启TCP Fast Open功能，减少一个RTT时间，提高连接建立的速度。需要确保客户端和服务端均支持该功能。

### TCP四次挥手

#### 主动方的优化

- **FIN报文重传**：主动方发起FIN报文来断开连接，如果未收到对方的ACK响应，则会重传FIN报文。重传次数由`tcp_orphan_retries`参数控制。
- 处理FIN_WAIT2状态
  - **孤儿连接处理**：如果使用`close`函数关闭连接，连接变为孤儿连接。如果在`tcp_fin_timeout`设定的时间内未收到对方的FIN报文，连接将被直接关闭。系统通过`tcp_max_orphans`参数限制孤儿连接的最大数量，防止它们过多占用资源。
  - **正常关闭**：使用`shutdown`函数关闭的连接不受`tcp_max_orphans`参数的影响。
- 管理TIME_WAIT状态
  - 连接在返回最终ACK后进入TIME_WAIT状态，通常持续1分钟。为防止TIME_WAIT状态过多占用资源，`tcp_max_tw_buckets`参数用于限制TIME_WAIT连接的最大数量。
  - 通过设置`tcp_tw_reuse`和`tcp_timestamps`为1，可以复用TIME_WAIT状态的端口用于作为客户端的新连接，但注意这仅适用于客户端。

#### 被动方的优化

- **管理CLOSE_WAIT状态**：被动方在收到FIN报文并回复ACK后，进入CLOSE_WAIT状态，等待应用程序调用`close`函数来关闭连接。若出现大量CLOSE_WAIT状态的连接，通常需要检查应用程序以确保它及时关闭连接。
- **处理LAST_ACK状态**：被动方在发送FIN报文后进入LAST_ACK状态，若未收到主动方的ACK确认，会根据`tcp_orphan_retries`参数控制下重发FIN报文。

### 滑动窗口的优化

1. **滑动窗口优化**：
   - TCP通过滑动窗口协议实现流控，保证数据传输的可靠性和效率。默认窗口大小64KB可能不足以满足高速网络的需求。
   - 开启`tcp_window_scaling`（设置为1），可以扩大滑动窗口大小至1GB，从而提升数据传输速度。
2. **带宽时延积和窗口大小**：
   - 理想的滑动窗口大小应接近带宽时延积（Bandwidth-Delay Product, BDP），以最大化网络利用率，避免过载和未充分利用。
3. **内核缓冲区设置**：
   - TCP缓冲区大小（`tcp_wmem`和`tcp_rmem`）决定了滑动窗口的实际上限，应根据网络的带宽时延积进行调整。
   - Linux系统提供动态缓冲区调整，通过设置`tcp_moderate_rcvbuf`为1启用接收缓冲区的自适应调节。
4. **避免手动设置缓冲区大小**：
   - 应用程序中直接设置`SO_SNDBUF`和`SO_RCVBUF`可能会关闭内核的动态缓冲区调整功能，建议让内核自动管理缓冲区大小。

___

## 如何理解是 TCP 面向字节流协议？

### 如何理解粘包

#### UDP面向报文

UDP协议在发送数据时不会对消息进行拆分，保持数据报文的完整性，使每个UDP数据报完全对应一个用户消息。因此，UDP被称为面向报文的协议。接收端通过系统调用`recvfrom()`从队列中读取完整的UDP报文。

#### TCP面向字节流

TCP在发送数据时，操作系统可能将一个完整的用户消息分割成多个TCP报文，根据网络状况进行传输，这导致接收方无法直接从单个TCP报文获取完整的用户消息。因此，TCP被称为面向字节流的协议，发送和接收的数据像流水一样连续，没有固定边界。

例如，发送方准备发送两个消息：“Hi.”和“I am Xiaolin”。发送时，可能会出现以下情况：

1. 这两个消息被合并到同一个TCP报文中发送。
2. “I am Xiaolin”的部分可能与“Hi”一起在一个TCP报文中发送。
3. “Hi.”的一部分可能与下一个消息的部分“ I am Xiaolin”一起在另一个TCP报文中发送。

#### 解决TCP粘包问题：添加长度字段

为解决TCP粘包问题，可以在每个消息前加入长度字段，明确指示消息的字节数。例如，发送“Hi Xiaolin”时，如果前置长度字段为10，则即使数据包在网络中被分为“[10][Hi Xi]”和“[aolin]”，接收方也能通过长度字段知道需要从字节流中收集总计10个字节来重组完整消息。这种方式确保了数据的完整性和正确解析，无论数据如何在网络中被分割。

### 解决TCP粘包问题的方法

TCP粘包是由于在传输过程中不清楚消息的边界而导致的数据接收错误。要解决这个问题，可以通过以下三种主要方法来定义消息边界：

#### 1. 固定长度的消息

这是最简单的方法，通过规定每个消息都具有固定的长度。例如，如果规定每个消息长度为64字节，接收方在接收到64字节后就认为收到了一个完整的消息。这种方法的缺点是灵活性较低，适用性有限。

#### 2. 特殊字符作为边界

在消息之间插入特殊字符（如HTTP协议中的回车符和换行符）来标示消息的结束。这种方法简单且在文本协议中使用广泛。但需要注意的是，如果消息本身可能包含边界字符，则需要对这些字符进行转义处理，以防止错误的边界识别。

#### 3. 自定义消息结构

通过自定义消息头来指示数据的长度。这种方法中，消息结构包括一个包头和数据体，包头固定大小，包含一个字段指明数据体的长度。例如，定义如下结构：

```
cCopy codestruct { 
    u_int32_t message_length;  // 数据长度
    char message_data[];       // 实际消息数据
}
```

接收方首先接收包头大小的数据（如4字节），解析出数据长度后，继续接收指定长度的数据直到完成，这样可以确保消息的完整性和正确性。

通过这些方法，可以有效地处理并解决TCP粘包问题，确保数据传输的准确性和可靠性。

___

## 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？

#### 问题背景

TCP连接在建立时每次都使用不同的初始化序列号（ISN）。这一设计主要是为了防止所谓的历史报文（来自旧连接的报文）被新连接错误地接收，从而造成数据错乱。

#### 时间等待与历史报文

在TCP的四次挥手过程中，TIME_WAIT状态确保了连接在结束后能持续一段时间（2MSL，即最大报文生存时间的两倍），使得在网络中仍在传输的报文能被正确处理，避免对后续连接的干扰。但在实际应用中，并非所有连接都能正常经过四次挥手结束，比如硬件故障导致的突然断电。

#### 历史报文问题

如果新的连接和上一个连接有相同的四元组信息（源IP、目的IP、源端口、目的端口）且序列号也相同，则历史报文有可能被错误地视为有效数据。为防止这种情况，每次连接初始化序列号的随机化显得尤为重要。如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有**大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。**

___

## SYN 报文什么时候情况下会被丢弃？

#### 1. 半连接队列满

当服务器的半连接队列（SYN队列）已满时，新的SYN报文将无法被接受，因此会被丢弃。这种情况通常发生在服务器面临高并发连接请求时。

#### 2. 完全连接队列满

即便SYN报文已经在半连接队列中，如果后续全连接队列（accept队列）已满，即使三次握手完成，新的连接也无法转入全连接队列中，导致SYN报文及其建立的连接被放弃。

#### 3. 安全策略和防火墙设置

网络安全设备或软件（如防火墙）可能配置了拦截某些类型或来自特定源的SYN报文的策略。如果SYN报文被识别为潜在的安全威胁，如SYN洪水攻击的一部分，它将被丢弃。

___

## 已建立连接的TCP，收到SYN会发生什么？

#### 场景描述

在一个已经建立的TCP连接中，如果客户端因故障中断连接并重启后，尝试重新建立连接，会发送一个新的SYN报文到服务端。这时，服务端如何处理这个报文取决于多个因素，特别是客户端的源端口是否与之前的连接相同。

#### 处理方式

1. **源端口不同**：
   - 如果客户端的新SYN报文中的源端口与之前的连接不同，服务端会认为这是一个全新的连接请求，并通过正常的三次握手过程尝试建立新的连接。
   - 旧连接如果服务端尝试发送数据，会收到客户端的RST报文，因为客户端不再认为这是一个有效的连接，服务端随后会关闭此连接。
   - 如果服务端在超时期间没有数据交互，TCP保活机制会触发，最终导致服务端释放连接。
2. **源端口相同**：
   - 如果客户端在故障恢复后发送的SYN报文中的源端口与原有连接中的端口相同，这意味着服务端收到一个看似属于已经建立的连接的SYN报文。
   - 在这种情况下，服务端会发送一个称为Challenge ACK的特殊ACK报文。这个ACK报文包含正确的序列号和确认号，目的是确认连接的状态。
   - 客户端在收到Challenge ACK后，会检查确认号。如果发现确认号与预期不符，客户端会发送一个RST报文，提示服务端关闭连接。

#### 内核实现和协议标准

- 根据RFC规范和Linux内核的实现，当TCP连接已经处于`Established`状态时，收到意外的SYN报文，服务端的响应是发送一个Challenge ACK。这是为了防止潜在的协议层攻击和确认连接的有效性。
- Challenge ACK的使用提供了一种机制来处理网络中的异常或错误，防止由于旧的或重复的SYN报文引起的连接问题。

#### 结论

这种处理机制显示了TCP协议的健壮性和对异常情况的考虑。它确保了即使在复杂的网络环境和设备故障情况下，也能正确地管理TCP连接，避免潜在的数据错乱。

___

## 关闭TCP连接的工具：tcpkill和killcx

当需要管理或干预TCP连接时，工具如tcpkill和killcx可用于通过伪造RST报文来关闭连接。这两种工具的工作原理和应用场景略有不同：

#### tcpkill工具

- **使用场景**：适用于活跃的TCP连接。
- **工作原理**：tcpkill工具工作时需等待TCP连接双方的数据交换，以便捕获并使用正确的序列号来发送RST报文。如果TCP连接处于非活跃状态而没有数据传输，tcpkill将无法获取正确的序列号，从而无法关闭连接。

#### killcx工具

- **使用场景**：可用于关闭活跃和非活跃的TCP连接。
- **工作原理**：killcx通过主动发送SYN报文来引诱对方回复Challenge ACK。从该ACK报文中，killcx可以获取正确的序列号，进而使用这个序列号来发送RST报文，有效关闭连接。

#### 为什么需要两个工具？

- **特定需求**：`tcpkill` 在可以捕获到流量的环境中速度快且效果好，适合实时流量管理。而`killcx` 在需要处理不活跃连接或在环境中无法直接捕获流量时更加有效。
- **安全与检测**：`tcpkill` 的行为更隐蔽，不容易引起安全设备的注意，而`killcx` 的行为可能会触发安全警报。
- **灵活性与控制**：两种工具提供了不同级别的控制，让网络管理员可以根据具体的网络环境和策略选择最合适的工具。

___

## TCP四次挥手中的乱序FIN包处理

1. **乱序FIN包的接收**：
   - 当TCP连接的一方接收到乱序的FIN包时，由于FIN包的序列号不匹配当前期望的序列号，它不会立即被视为有效结束连接的信号。相反，它被视为乱序数据包处理。
2. **缓存乱序FIN包**：
   - TCP实现通常会将这个乱序的FIN包放入缓存，等待之前遗失或延迟的数据包的到来。只有在所有前面的数据都正确接收并按序处理后，乱序的FIN包才会被取出并处理。
3. **确认和关闭连接**：
   - 一旦所有缺失的数据包都已接收并正确排序，TCP协议栈将处理缓存中的FIN包。此时，接收方会发送一个ACK包来确认FIN包，然后执行自己的关闭序列，这可能包括发送自己的FIN包。
4. **连接状态转移**：
   - 在发送对FIN包的确认后，接收方的TCP状态会转变为关闭序列的下一个阶段（例如从`ESTABLISHED`到`CLOSE_WAIT`）。

___

## TCP TIME_WAIT状态下对SYN包的处理

#### 结论概述

在TCP的TIME_WAIT状态中，如果收到新的SYN包，TCP栈会根据SYN包的序列号和时间戳来决定如何处理这个包。这里的关键是判断SYN包的序列号和时间戳是否“合法”。

#### 合法性判断

- **合法的SYN**：客户端的SYN的序列号大于服务端期望的下一个序列号，且SYN的时间戳大于服务端最后收到的报文的时间戳。
- **非法的SYN**：客户端的SYN的序列号小于服务端期望的下一个序列号，或SYN的时间戳小于服务端最后收到的报文的时间戳。

这种判断依赖于双方是否启用了TCP时间戳机制。如果未启用，仅比较序列号。

#### 处理流程

- **收到合法的SYN**：如果TIME_WAIT状态的连接收到合法的SYN，它会重用该四元组连接，跳过2MSL等待期，转变为SYN_RECV状态，开始新的连接建立过程。

  示例：服务端处于TIME_WAIT状态，记录了最后一个FIN包的时间戳（假设为21）和下一个期望的序列号（假设为301）。若收到一个SYN包，其序列号为400，时间戳为30，这是合法的SYN，因此会重用连接，转为SYN_RECV状态。

- **收到非法的SYN**：如果TIME_WAIT状态的连接收到非法的SYN，它将回复一个与第四次挥手相同的ACK报文。客户端接收后，由于确认号不符合预期，通常会回复一个RST报文给服务端。

#### 源码分析

Linux内核中处理TIME_WAIT状态的报文的逻辑如下：

1. 如果收到的是SYN包，根据时间戳和序列号的合法性，选择是否重用连接或延长TIME_WAIT状态。
2. 对于合法的SYN，初始化新的序列号，准备接收新的连接。
3. 对于非法的SYN，发送旧的ACK响应，或者根据情况处理RST或ACK包。

#### 参数影响

Linux内核参数`net.ipv4.tcp_rfc1337`影响TIME_WAIT状态下对RST的处理：

- **值为0**：收到RST时提前结束TIME_WAIT状态，释放连接。
- **值为1**：忽略RST报文，继续维持TIME_WAIT状态，以避免可能的问题。

#### 结论

在TIME_WAIT状态下，处理新的SYN包的策略旨在保证网络通信的可靠性和安全性。根据SYN包的序列号和时间戳的合法性，TCP协议能够决定是重启连接还是维持现有的连接状态。同时，对于TIME_WAIT状态的管理，应谨慎配置相关的内核参数，以防止潜在的网络安全风险。

___

## TCP连接，一端断电和进程崩溃有什么区别

在TCP网络通信中，客户端进程崩溃和客户端主机宕机会对已建立的TCP连接产生不同的影响。具体处理方式取决于服务端的响应和配置。

#### 客户端进程崩溃

- 当客户端进程崩溃时，客户端的操作系统内核通常会负责清理该进程持有的资源，包括打开的TCP连接。这通常涉及发送一个FIN报文到服务端，触发TCP四次挥手过程，正常关闭连接。

#### 客户端主机宕机

- 如果是客户端主机宕机，情况则完全不同，因为主机宕机意味着所有运行的进程和服务突然停止，包括TCP栈的操作。这种情况下，不会有FIN报文发送到服务端，服务端不会立即意识到客户端已经不可达。此时，服务端对TCP连接的处理取决于以下几点：

1. **服务端尝试发送数据**：
   - 如果服务端尝试发送数据给客户端，那么因为客户端主机宕机，服务端不会收到任何ACK确认。这将导致服务端TCP栈开始重传数据报文。
   - 重传会一直进行，直到超过一定的重试次数（由内核参数`tcp_retries2`控制）。一旦超过这个阈值，服务端会放弃并关闭连接，认为网络不可达或客户端故障。
2. **服务端未发送数据**：
   - 如果服务端没有数据要发送，且没有开启TCP keepalive机制，那么服务端可能永远不会意识到客户端已经宕机。在这种情况下，TCP连接会一直保持在`ESTABLISHED`状态。
   - 如果服务端启用了TCP keepalive机制，那么在经过配置的keepalive时间后，服务端将开始发送探测包。如果探测失败（即没有收到客户端的响应），服务端将继续尝试直到超过设定的探测次数，最终断开连接。

___

## 客户端拔掉网线对TCP连接的影响

当客户端拔掉网线，TCP连接的存续与否取决于此后是否有数据传输以及TCP keepalive机制的设置：

#### 有数据传输

1. **网线重新连接前服务端数据重传未超限**：
   - 如果服务端在客户端重新连接网线前的数据重传次数未达到上限，TCP连接将继续保持，数据交换可以正常进行。
2. **网线重新连接前服务端数据重传超限**：
   - 如果服务端的数据重传次数达到最大值，服务端将关闭TCP连接。客户端网线重新连接后，任何试图通信的行为将被服务端以RST响应，导致客户端也关闭连接。

#### 无数据传输

1. **TCP keepalive机制未开启**：
   - 如果TCP keepalive未启用，且双方无数据传输，TCP连接状态将保持不变，即使客户端网线未重新连接。
2. **TCP keepalive机制开启**：
   - 如果开启了TCP keepalive，一旦探测到对方无响应，连接将被关闭。如果客户端在探测期间重新连接网线，TCP连接仍可继续使用。

#### 特殊情况：客户端宕机与进程崩溃

- **客户端宕机**：类似于拔网线，服务端无法立即察觉，除非有数据传输或启用了keepalive机制。
- **进程崩溃**：客户端操作系统会自动发送FIN报文，触发与服务端的四次挥手过程，正常关闭TCP连接。

___

tcp_tw_reuse 的作用是让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态，这可能会出现这样的两个问题：

- 历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。
- 如果第四次挥手的 ACK 报文丢失了，在`TIME_WAIT`状态快速复用后，客户端发送的SYN报文被还在`LAST_ACK`状态的服务端接收，服务端将发送一个Challenge ACK，客户端因确认号不符将回复RST导致服务端断开连接。

虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。

___

## TLS和TCP能同时握手吗

1. **标准HTTPS连接**：首先完成TCP的三次握手，随后进行TLS 1.2的四次握手，这是HTTPS协议的标准连接过程。
2. **优化的HTTPS连接**：HTTPS连接中的TLS握手过程能与TCP三次握手同时进行，但这种情况需要满足特定条件：
   - 必须启用TCP Fast Open功能。
   - 使用TLS 1.3版本。
   - 客户端和服务端之间已有先前的成功通信记录。

___

### TCP Keepalive

**定义和层级**：TCP Keepalive 是位于传输层的一个机制，用于检测两个TCP连接端点（通常是客户端和服务器）之间的连接是否仍然有效。它主要用于在长时间无数据传输活动时检测死连接或不可达的对端。

**工作原理**：通过周期性地发送探测包给对方，如果在指定的时间内未收到响应，则认为对方不可达，并将连接视为已断开。

**应用场景**：在某些需要长连接的应用中非常有用，比如数据库连接、远程桌面会话等。

### HTTP Keep-Alive

**定义和层级**：HTTP Keep-Alive 是位于应用层的机制，属于HTTP协议的一部分，用于在一个TCP连接上发送和接收多个HTTP请求/响应，而不是每次交互后就关闭连接。

**工作原理**：通过在HTTP头部加入 `Connection: keep-alive`，告诉对方在发送响应后保持连接打开，从而减少建立和关闭连接的开销。

**应用场景**：适用于Web服务器和浏览器之间的通信，可以显著提高网页加载速度，因为多个资源文件（如图片、脚本、样式表）可以通过同一个持久连接顺序加载。

### Keepalive 的双向性

无论是 TCP Keepalive 还是 HTTP Keep-Alive，它们都可以由任意一方发起。对于TCP Keepalive，操作系统通常提供配置参数以决定何时以及如何发送TCP Keepalive包。对于HTTP Keep-Alive，则由客户端通过HTTP请求头部指定，服务器可以在响应中同意保持连接，或者忽略此请求并关闭连接。

**总结**：Keepalive机制可以由服务端或客户端发起，目的是为了维护长时间的连接状态，减少建立和关闭连接的频繁操作，从而提高网络通信的效率和性能。

HTTP Keep-Alive 和 TCP Keepalive 同时存在是为了在不同层面优化网络通信和资源管理。HTTP Keep-Alive 减少了因频繁建立和关闭连接而产生的开销，提高了 HTTP 请求的效率；而 TCP Keepalive 则确保底层的 TCP 连接仍然可靠和活跃，有助于检测和处理“僵尸连接”。这两种机制共存，使得网络应用可以在提高性能的同时，保持连接的稳定性和可靠性。

___

## TCP 协议有什么缺陷？

1. **升级困难**：TCP 协议的实现是嵌入在操作系统内核中的，任何升级都需要通过更新内核来实现。这不仅涉及到底层软件和运行库的更新，还需要进行广泛的兼容性测试，使得在实际部署中升级过程缓慢且保守。
2. **建立连接的延迟**：TCP 需要通过三次握手过程建立连接，这在一定程度上增加了数据传输的延迟。对于使用 HTTPS 的网站来说，还需要经过额外的 TLS 四次握手，进一步增加了延迟。
3. **队头阻塞问题**：TCP 保证数据的完整性和顺序，导致如果一个数据包丢失，后续接收到的数据包即使完整也必须等待丢失的数据包被正确接收并处理后才能被应用层读取。这种队头阻塞会影响整个 TCP 连接的效率。
4. **网络迁移问题**：TCP 连接是基于 IP 地址和端口的四元组标识的。当设备的网络环境发生变化（例如从移动网络切换到 WiFi）时，IP 地址的变化导致必须重新建立 TCP 连接，这不仅增加了延迟，还可能导致用户体验的短暂中断。

___

## TCP 和 UDP 可以使用同一个端口吗？

1. TCP和UDP端口绑定

- **TCP和UDP端口独立性**：TCP和UDP是两个独立的模块，它们可以同时绑定相同的端口号，因为系统根据IP包头中的协议号来区分处理TCP或UDP数据包。
- **多个TCP服务进程绑定同一端口**：如果多个TCP服务进程尝试绑定完全相同的IP地址和端口号，系统会报错“Address already in use”。如果绑定的端口相同但IP地址不同（如使用不同的网络接口），则不会冲突。

2. 解决服务端重启时的端口占用问题

- **TIME_WAIT状态和端口重用**：服务端在重启时可能会遇到端口被TIME_WAIT状态的连接占用的问题。通过设置SO_REUSEADDR选项，允许在同一端口上绑定新的套接字，即使该端口已被TIME_WAIT状态的连接占用。

3. 客户端端口重复使用

- **客户端端口管理**：客户端可以重复使用相同的端口与不同的服务器建立连接，因为TCP连接由IP地址和端口的四元组（源IP、源端口、目的IP、目的端口）唯一确定，不同的目标服务器不会冲突。

4. 客户端TIME_WAIT状态的管理

- **端口资源耗尽问题**：如果客户端与同一服务器建立大量短暂的连接，可能会导致端口资源耗尽，因为每个连接在结束后都会进入TIME_WAIT状态。
- **解决方案**：启用内核参数net.ipv4.tcp_tw_reuse，允许系统在合适的情况下重用处于TIME_WAIT状态的端口。这通常用于连接建立频繁且短暂的场景，有助于提高端口的利用率并减少资源耗尽的风险。

___

## 服务端没有 listen，客户端发起连接建立，会发生什么？

在 TCP 网络通信中，`listen()` 函数通常用于服务器端准备接受来自客户端的连接请求。这个函数使服务器能够接受并处理来自客户端的多个连接，在此过程中，服务器维护了半连接队列和全连接队列来管理各个连接状态。但是，在某些特殊情况下，TCP连接也可以在没有执行`listen()`的情况下建立。这主要涉及两种情况：

1. **TCP自连接**：一个客户端进程尝试连接到其自身的同一个端口上，形成了所谓的“自连接”。在这种情况下，发送和接收的握手包都是由同一个主机和端口发起和接收，因此不需要`listen()`去等待外部的连接请求。
2. **TCP同时打开**：两个客户端进程同时尝试建立连接，彼此同时发送连接请求（SYN包）并响应（ACK包）。由于这种情况下每个端都同时扮演了客户端和服务器的角色，所以也无需执行`listen()`。

在这些情况下，尽管没有使用`listen()`来明确等待入站连接，TCP连接仍然可以通过内核中的全局哈希表来管理和存放连接信息。这个全局哈希表记录了所有激活的连接信息，使得即使在没有半连接或全连接队列的情况下，连接仍能根据IP和端口信息匹配并成功建立。

___

## 没有 accept，能建立 TCP 连接吗？

1. **队列创建**：当 socket 执行 `listen` 时，内核创建半连接队列和全连接队列。
2. 队列功能
   - **半连接队列**：存放完成前两次握手的 TCP 连接。
   - **全连接队列**：存放完成三次握手的连接。
3. **`accept` 方法**：用于从全连接队列中提取已建立的连接，与三次握手过程本身无直接关系。
4. 队列设计
   - **半连接队列**：设计为哈希表，优化查找效率。
   - **全连接队列**：本质为链表，便于添加和移除连接。
5. 队列溢出处理
   - **全连接队列满**：进一步的连接尝试会被拒绝，可能发送 RST。
   - **半连接队列满**：可能指示 SYN Flood 攻击，可通过启用 `tcp_syncookies` 来绕过。
6. **客户端设计**：没有队列，但使用全局哈希表管理连接，支持如自连接或 TCP 同时打开的操作。

___

## 用了 TCP 协议，数据一定不会丢吗？

1. **TCP 重传机制**：虽然丢包是常态，但在日常使用中，TCP协议通过其内建的重传机制保证了数据的可靠性。只有在网络质量极差的情况下，这种机制才可能无法完全补偿丢失的数据。
2. **监控和诊断工具**：
   - **Ping命令**：用于测试网络连接质量和延迟，可以快速检测到链路上的基本问题。
   - **MTR命令**：结合了Ping和TraceRoute的功能，提供关于网络链路状态和丢包位置的详细信息，非常适用于诊断持续的连接问题或高延迟问题。
3. **应用层可靠性**：尽管TCP保证了传输层的消息可靠性，它并不直接保证应用层的数据完整性和顺序。要在应用层实现消息的可靠传输，需要通过应用层的逻辑来额外管理，如：
   - **消息确认机制**：发送端在接收到接收端的确认消息前，保持对已发送消息的记录。
   - **数据校验**：通过加入哈希值、校验和等方法来确保数据在传输过程中未被篡改。

___

## 四次挥手，可以变成三次吗？

在TCP连接的终止过程中，通常涉及四次挥手。不过，在某些特定情况下，实际的挥手次数可能减少到三次，这通常发生在如下情况：

1. **没有数据要发送**：当被动关闭方（即接收到关闭请求的一方）在收到FIN信号后，如果此时没有任何待发送的数据。
2. **TCP 延迟确认机制**：通常情况下，TCP连接没有开启`TCP_QUICKACK`选项，这意味着会使用TCP的延迟确认机制。在这种机制下，TCP不会立即发送ACK响应，而是可能将确认的发送延迟，以便与其他出站数据一起发送。

当上述两个条件同时满足时，被动关闭方在收到FIN后，如果没有要发送的数据，可能会立即发送ACK确认，并在同一个段中发送自己的FIN。因此，第二次（被动方的ACK）和第三次挥手（被动方的FIN）会合并为一个单一的响应。这样，整个挥手过程就缩减为三次：首先是主动方的FIN，接着是被动方的FIN-ACK合并响应，最后是主动方的ACK。
